"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from collections.abc import MutableMapping

"""Utility functions that cannot be categorised anywhere else."""
__all__ = ("dbl_epsilon", "deprecated", "multidict", "named_temporary_file", "numpy_to_contiguous_memoryview", "rescale", "safemin", "safemax")
__docformat__ = ...
def deprecated(message): # -> None:
    """Prints a warning message related to the deprecation of some igraph
    feature."""
    ...

@contextmanager
def named_temporary_file(*args, **kwds): # -> Generator[Any, Any, None]:
    """Context manager that creates a named temporary file and
    returns its name.

    All parameters are passed on to ``tempfile.mkstemp``, see
    its documentation for more info.
    """
    ...

def numpy_to_contiguous_memoryview(obj): # -> memoryview[int]:
    """Converts a NumPy array or matrix into a contiguous memoryview object
    that is suitable to be forwarded to the Graph constructor.

    This is used internally to allow us to use a NumPy array or matrix
    directly when constructing a Graph.
    """
    ...

def rescale(values, out_range=..., in_range=..., clamp=..., scale=...): # -> list[Any] | list[float]:
    """Rescales a list of numbers into a given range.

    ``out_range`` gives the range of the output values; by default, the minimum
    of the original numbers in the list will be mapped to the first element
    in the output range and the maximum will be mapped to the second element.
    Elements between the minimum and maximum values in the input list will be
    interpolated linearly between the first and second values of the output
    range.

    ``in_range`` may be used to override which numbers are mapped to the first
    and second values of the output range. This must also be a tuple, where
    the first element will be mapped to the first element of the output range
    and the second element to the second.

    If ``clamp`` is ``True``, elements which are outside the given ``out_range``
    after rescaling are clamped to the output range to ensure that no number
    will be outside ``out_range`` in the result.

    If ``scale`` is not ``None``, it will be called for every element of ``values``
    and the rescaling will take place on the results instead. This can be used,
    for instance, to transform the logarithm of the original values instead of
    the actual values. A typical use-case is to map a range of values to color
    identifiers on a logarithmic scale. Scaling also applies to the ``in_range``
    parameter if present.

    :param out_range: the range of output values
    :param in_range: the range of the input values; this is the range that is mapped
        to ``out_range``. ``None`` means to use the minimum and maximum of
        the input, respectively.
    :param clamp: specifies what to do when an input value falls outside ``in_range``.
        ``True`` means to clamp the value to the bounds of ``in_range``,
        ``False`` means not to clamp.
    :param scale: an optional transformation to perform on the input values before
        mapping them to the output range.

    Examples:

        >>> rescale(range(5), (0, 8))
        [0.0, 2.0, 4.0, 6.0, 8.0]
        >>> rescale(range(5), (2, 10))
        [2.0, 4.0, 6.0, 8.0, 10.0]
        >>> rescale(range(5), (0, 4), (1, 3))
        [-2.0, 0.0, 2.0, 4.0, 6.0]
        >>> rescale(range(5), (0, 4), (1, 3), clamp=True)
        [0.0, 0.0, 2.0, 4.0, 4.0]
        >>> rescale([0]*5, (1, 3))
        [2.0, 2.0, 2.0, 2.0, 2.0]
        >>> from math import log10
        >>> rescale([1, 10, 100, 1000, 10000], (0, 8), scale=log10)
        [0.0, 2.0, 4.0, 6.0, 8.0]
        >>> rescale([1, 10, 100, 1000, 10000], (0, 4), (10, 1000), scale=log10)
        [-2.0, 0.0, 2.0, 4.0, 6.0]
    """
    ...

def consecutive_pairs(iterable, circular=...): # -> Generator[tuple[Any, Any], Any, None]:
    """Returns consecutive pairs of items from the given iterable.

    When ``circular`` is ``True``, the pair consisting of the last
    and first elements is also returned.

    Example:

        >>> list(consecutive_pairs(range(5)))
        [(0, 1), (1, 2), (2, 3), (3, 4)]
        >>> list(consecutive_pairs(range(5), circular=True))
        [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]
        >>> list(consecutive_pairs([]))
        []
        >>> list(consecutive_pairs([], circular=True))
        []
        >>> list(consecutive_pairs([0]))
        []
        >>> list(consecutive_pairs([0], circular=True))
        [(0, 0)]
    """
    ...

class multidict(MutableMapping):
    """A dictionary-like object that is customized to deal with multiple
    values for the same key.

    Each value in this dictionary will be a list. Methods which emulate
    the methods of a standard Python ``dict`` object will return or manipulate
    the first items of the lists only. Special methods are provided to
    deal with keys having multiple values.
    """
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        """Returns whether there are any items associated to the given
        ``key``."""
        ...
    
    def __delitem__(self, key): # -> None:
        """Removes all the items associated to the given ``key``."""
        ...
    
    def __getitem__(self, key):
        """Returns an arbitrary item associated to the given key. Raises ``KeyError``
        if no such key exists.

        Example:

            >>> d = multidict([("spam", "eggs"), ("spam", "bacon")])
            >>> d["spam"]
            'eggs'
        """
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        """Iterates over the keys of the multidict."""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of distinct keys in this multidict."""
        ...
    
    def __setitem__(self, key, value): # -> None:
        """Sets the item associated to the given ``key``. Any values associated to the
        key will be erased and replaced by ``value``.

        Example:

           >>> d = multidict([("spam", "eggs"), ("spam", "bacon")])
           >>> d["spam"] = "ham"
           >>> d["spam"]
           'ham'
        """
        ...
    
    def add(self, key, value): # -> None:
        """Adds `value` to the list of items associated to ``key``.

        Example:

            >>> d = multidict()
            >>> d.add("spam", "ham")
            >>> d["spam"]
            'ham'
            >>> d.add("spam", "eggs")
            >>> d.getlist("spam")
            ['ham', 'eggs']
        """
        ...
    
    def clear(self): # -> None:
        """Removes all the items from the multidict."""
        ...
    
    def get(self, key, default=...): # -> None:
        """Returns an arbitrary item associated to the given ``key``. If ``key``
        does not exist or has zero associated items, ``default`` will be
        returned."""
        ...
    
    def getlist(self, key): # -> list[Any]:
        """Returns the list of values for the given ``key``. An empty list will
        be returned if there is no such key."""
        ...
    
    def iterlists(self): # -> Iterator[tuple[Any, Any]]:
        """Iterates over ``(key, values)`` pairs where ``values`` is the list
        of values associated with ``key``."""
        ...
    
    def lists(self): # -> list[tuple[Any, Any]]:
        """Returns a list of ``(key, values)`` pairs where ``values`` is the list
        of values associated with ``key``."""
        ...
    
    def update(self, arg, **kwds): # -> None:
        ...
    


def safemax(iterable, default=...): # -> int:
    """Safer variant of ``max()`` that returns a default value if the iterable
    is empty.

    Example:

        >>> safemax([-5, 6, 4])
        6
        >>> safemax([])
        0
        >>> safemax((), 2)
        2
    """
    ...

def safemin(iterable, default=...): # -> int:
    """Safer variant of ``min()`` that returns a default value if the iterable
    is empty.

    Example:

        >>> safemin([-5, 6, 4])
        -5
        >>> safemin([])
        0
        >>> safemin((), 2)
        2
    """
    ...

def dbl_epsilon(): # -> float:
    """Approximates the machine epsilon value for doubles."""
    ...

dbl_epsilon = ...
