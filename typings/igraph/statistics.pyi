"""
This type stub file was generated by pyright.
"""

"""
Statistics related stuff in igraph
"""
__all__ = ("FittedPowerLaw", "Histogram", "RunningMean", "mean", "median", "percentile", "quantile", "power_law_fit")
class FittedPowerLaw:
    """Result of fitting a power-law to a vector of samples

    Example:

        >>> result = power_law_fit([1, 2, 3, 4, 5, 6])
        >>> result                   # doctest:+ELLIPSIS
        FittedPowerLaw(continuous=False, alpha=2.42..., xmin=3.0, L=-7.54..., \
D=0.21..., p=0.993...)
        >>> print(result)            # doctest:+ELLIPSIS
        Fitted power-law distribution on discrete data
        <BLANKLINE>
        Exponent (alpha)  = 2.42...
        Cutoff (xmin)     = 3.000000
        <BLANKLINE>
        Log-likelihood    = -7.54...
        <BLANKLINE>
        H0: data was drawn from the fitted distribution
        <BLANKLINE>
        KS test statistic = 0.21...
        p-value           = 0.993...
        <BLANKLINE>
        H0 could not be rejected at significance level 0.05
        >>> result.alpha             # doctest:+ELLIPSIS
        2.42...
        >>> result.xmin
        3.0
        >>> result.continuous
        False
    """
    def __init__(self, continuous, alpha, xmin, L, D, p) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def summary(self, significance=...): # -> str:
        """Returns the summary of the power law fit.

        @param significance: the significance level of the Kolmogorov-Smirnov test
          used to decide whether the input data could have come from the fitted
          distribution
        @return: the summary as a string
        """
        ...
    


class Histogram:
    """Generic histogram class for real numbers

    Example:

        >>> h = Histogram(5)     # Initializing, bin width = 5
        >>> h << [2,3,2,7,8,5,5,0,7,9]     # Adding more items
        >>> print(h)
        N = 10, mean +- sd: 4.8000 +- 2.9740
        [ 0,  5): **** (4)
        [ 5, 10): ****** (6)
    """
    def __init__(self, bin_width=..., data=...) -> None:
        """Initializes the histogram with the given data set.

        @param bin_width: the bin width of the histogram.
        @param data: the data set to be used. Must contain real numbers.
        """
        ...
    
    @property
    def n(self): # -> int:
        """Returns the number of elements in the histogram"""
        ...
    
    @property
    def mean(self): # -> float:
        """Returns the mean of the elements in the histogram"""
        ...
    
    @property
    def sd(self): # -> float:
        """Returns the standard deviation of the elements in
        the histogram"""
        ...
    
    @property
    def var(self): # -> float:
        """Returns the variance of the elements in the histogram"""
        ...
    
    def add(self, num, repeat=...): # -> None:
        """Adds a single number to the histogram.

        @param num: the number to be added
        @param repeat: number of repeated additions
        """
        ...
    
    def add_many(self, data): # -> None:
        """Adds a single number or the elements of an iterable to the histogram.

        @param data: the data to be added"""
        ...
    
    __lshift__ = ...
    def clear(self): # -> None:
        """Clears the collected data"""
        ...
    
    def bins(self): # -> Generator[tuple[float | None, Any | float, int], Any, None]:
        """Generator returning the bins of the histogram in increasing order

        @return: a tuple with the following elements: left bound, right bound,
          number of elements in the bin"""
        ...
    
    def __plot__(self, backend, context, **kwds): # -> None:
        """Plotting support"""
        ...
    
    def to_string(self, max_width=..., show_bars=..., show_counts=...): # -> str:
        """Returns the string representation of the histogram.

        @param max_width: the maximal width of each line of the string
          This value may not be obeyed if it is too small.
        @param show_bars: specify whether the histogram bars should be shown
        @param show_counts: specify whether the histogram counts should be
          shown. If both I{show_bars} and I{show_counts} are C{False},
          only a general descriptive statistics (number of elements, mean and
          standard deviation) is shown.
        """
        ...
    
    def __str__(self) -> str:
        ...
    


class RunningMean:
    """Running mean calculator.

    This class can be used to calculate the mean of elements from a
    list, tuple, iterable or any other data source. The mean is
    calculated on the fly without explicitly summing the values,
    so it can be used for data sets with arbitrary item count. Also
    capable of returning the standard deviation (also calculated on
    the fly)
    """
    def __init__(self, items=..., n=..., mean=..., sd=...) -> None:
        """RunningMean(items=None, n=0.0, mean=0.0, sd=0.0)

        Initializes the running mean calculator.

        There are two possible ways to initialize the calculator.
        First, one can provide an iterable of items; alternatively,
        one can specify the number of items, the mean and the
        standard deviation if we want to continue an interrupted
        calculation.

        @param items: the items that are used to initialize the
          running mean calcuator. If C{items} is given, C{n},
          C{mean} and C{sd} must be zeros.
        @param n: the initial number of elements already processed.
          If this is given, C{items} must be C{None}.
        @param mean: the initial mean. If this is given, C{items}
          must be C{None}.
        @param sd: the initial standard deviation. If this is given,
          C{items} must be C{None}."""
        ...
    
    def add(self, value, repeat=...): # -> None:
        """RunningMean.add(value, repeat=1)

        Adds the given value to the elements from which we calculate
        the mean and the standard deviation.

        @param value: the element to be added
        @param repeat: number of repeated additions
        """
        ...
    
    def add_many(self, values): # -> None:
        """RunningMean.add(values)

        Adds the values in the given iterable to the elements from
        which we calculate the mean. Can also accept a single number.
        The left shift (C{<<}) operator is aliased to this function,
        so you can use it to add elements as well:

          >>> rm=RunningMean()
          >>> rm << [1,2,3,4]
          >>> rm.result               # doctest:+ELLIPSIS
          (2.5, 1.290994...)

        @param values: the element(s) to be added
        @type values: iterable"""
        ...
    
    def clear(self): # -> None:
        """Resets the running mean calculator."""
        ...
    
    @property
    def result(self): # -> tuple[float | Any, float | Any]:
        """Returns the current mean and standard deviation as a tuple"""
        ...
    
    @property
    def mean(self): # -> float:
        """Returns the current mean"""
        ...
    
    @property
    def sd(self): # -> float:
        """Returns the current standard deviation"""
        ...
    
    @property
    def var(self): # -> float:
        """Returns the current variation"""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    __lshift__ = ...
    def __float__(self): # -> float:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __complex__(self): # -> complex:
        ...
    
    def __len__(self): # -> int:
        ...
    


def mean(xs): # -> float:
    """Returns the mean of an iterable.

    Example:

        >>> mean([1, 4, 7, 11])
        5.75

    @param xs: an iterable yielding numbers.
    @return: the mean of the numbers provided by the iterable.

    @see: RunningMean() if you also need the variance or the standard deviation
    """
    ...

def median(xs, sort=...): # -> float:
    """Returns the median of an unsorted or sorted numeric vector.

    @param xs: the vector itself.
    @param sort: whether to sort the vector. If you know that the vector is
      sorted already, pass C{False} here.
    @return: the median, which will always be a float, even if the vector
      contained integers originally.
    """
    ...

def percentile(xs, p=..., sort=...): # -> list[Any]:
    """Returns the pth percentile of an unsorted or sorted numeric vector.

    This is equivalent to calling quantile(xs, p/100.0); see L{quantile}
    for more details on the calculation.

    Example:

        >>> round(percentile([15, 20, 40, 35, 50], 40), 2)
        26.0
        >>> for perc in percentile([15, 20, 40, 35, 50], (0, 25, 50, 75, 100)):
        ...     print("%.2f" % perc)
        ...
        15.00
        17.50
        35.00
        45.00
        50.00

    @param xs: the vector itself.
    @param p: the percentile we are looking for. It may also be a list if you
      want to calculate multiple quantiles with a single call. The default
      value calculates the 25th, 50th and 75th percentile.
    @param sort: whether to sort the vector. If you know that the vector is
      sorted already, pass C{False} here.
    @return: the pth percentile, which will always be a float, even if the vector
      contained integers originally. If p is a list, the result will also be a
      list containing the percentiles for each item in the list.
    """
    ...

def power_law_fit(data, xmin=..., method=..., p_precision=...): # -> FittedPowerLaw:
    """Fitting a power-law distribution to empirical data

    B{References}

      - MEJ Newman: Power laws, Pareto distributions and Zipf's law.
        I{Contemporary Physics} 46, 323-351 (2005)
      - A Clauset, CR Shalizi, MEJ Newman: Power-law distributions
        in empirical data. E-print (2007). arXiv:0706.1062

    @param data: the data to fit, a list containing integer values
    @param xmin: the lower bound for fitting the power-law. If C{None},
      the optimal xmin value will be estimated as well. Zero means that
      the smallest possible xmin value will be used.
    @param method: the fitting method to use. The following methods are
      implemented so far:

        - C{continuous}, C{hill}: exact maximum likelihood estimation
          when the input data comes from a continuous scale. This is
          known as the Hill estimator. The statistical error of
          this estimator is M{(alpha-1) / sqrt(n)}, where alpha is the
          estimated exponent and M{n} is the number of data points above
          M{xmin}. The estimator is known to exhibit a small finite
          sample-size bias of order M{O(n^-1)}, which is small when
          M{n > 100}. igraph will try to compensate for the finite sample
          size if n is small.

        - C{discrete}: exact maximum likelihood estimation when the
          input comes from a discrete scale (see Clauset et al. among the
          references).

        - C{auto}: exact maximum likelihood estimation where the continuous
          method is used if the input vector contains at least one fractional
          value and the discrete method is used if the input vector contains
          integers only.
    @param p_precision: desired precision of the p-value calculation. The
      precision ultimately depends on the number of resampling attempts. The
      number of resampling trials is determined by 0.25 divided by the square
      of the required precision. For instance, a required precision of 0.01
      means that 2500 samples will be drawn.

    @return: a L{FittedPowerLaw} object. The fitted C{xmin} value and the
      power-law exponent can be queried from the C{xmin} and C{alpha}
      properties of the returned object.
    """
    ...

def quantile(xs, q=..., sort=...): # -> list[Any]:
    """Returns the qth quantile of an unsorted or sorted numeric vector.

    There are a number of different ways to calculate the sample quantile. The
    method implemented by igraph is the one recommended by NIST. First we
    calculate a rank n as q(N+1), where N is the number of items in xs, then we
    split n into its integer component k and decimal component d. If k <= 1,
    we return the first element; if k >= N, we return the last element,
    otherwise we return the linear interpolation between xs[k-1] and xs[k]
    using a factor d.

    Example:

        >>> round(quantile([15, 20, 40, 35, 50], 0.4), 2)
        26.0

    @param xs: the vector itself.
    @param q: the quantile we are looking for. It may also be a list if you
      want to calculate multiple quantiles with a single call. The default
      value calculates the 25th, 50th and 75th percentile.
    @param sort: whether to sort the vector. If you know that the vector is
      sorted already, pass C{False} here.
    @return: the qth quantile, which will always be a float, even if the vector
      contained integers originally. If q is a list, the result will also be a
      list containing the quantiles for each item in the list.
    """
    ...

def sd(xs): # -> float:
    """Returns the standard deviation of an iterable.

    Example:

        >>> sd([1, 4, 7, 11])       #doctest:+ELLIPSIS
        4.2720...

    @param xs: an iterable yielding numbers.
    @return: the standard deviation of the numbers provided by the iterable.

    @see: RunningMean() if you also need the mean
    """
    ...

def var(xs): # -> float:
    """Returns the variance of an iterable.

    Example:

        >>> var([1, 4, 8, 11])            #doctest:+ELLIPSIS
        19.333333...

    @param xs: an iterable yielding numbers.
    @return: the variance of the numbers provided by the iterable.

    @see: RunningMean() if you also need the mean
    """
    ...

