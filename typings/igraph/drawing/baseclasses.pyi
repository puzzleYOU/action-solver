"""
This type stub file was generated by pyright.
"""

from abc import ABCMeta, abstractmethod

"""
Abstract base classes for the drawing routines.
"""
class AbstractDrawer(metaclass=ABCMeta):
    """Abstract class that serves as a base class for anything that
    draws an igraph object."""
    @abstractmethod
    def draw(self, *args, **kwds):
        """Abstract method, must be implemented in derived classes."""
        ...
    


class AbstractXMLRPCDrawer(AbstractDrawer):
    """Abstract drawer that uses a remote service via XML-RPC
    to draw something on a remote display.
    """
    def __init__(self, url, service=...) -> None:
        """Constructs an abstract drawer using the XML-RPC service
        at the given URL.

        @param url: the URL where the XML-RPC calls for the service should
          be addressed to.
        @param service: the name of the service at the XML-RPC address. If
          C{None}, requests will be directed to the server proxy object
          constructed by C{xmlrpclib.ServerProxy}; if not C{None}, the
          given attribute will be looked up in the server proxy object.
        """
        ...
    


class AbstractEdgeDrawer(metaclass=ABCMeta):
    """Abstract edge drawer object from which all concrete edge drawer
    implementations are derived.
    """
    @abstractmethod
    def draw_directed_edge(self, edge, src_vertex, dest_vertex):
        """Draws a directed edge.

        @param edge: the edge to be drawn. Visual properties of the edge
          are defined by the attributes of this object.
        @param src_vertex: the source vertex. Visual properties are defined
          by the attributes of this object.
        @param dest_vertex: the source vertex. Visual properties are defined
          by the attributes of this object.
        """
        ...
    
    @abstractmethod
    def draw_undirected_edge(self, edge, src_vertex, dest_vertex):
        """Draws an undirected edge.

        @param edge: the edge to be drawn. Visual properties of the edge
          are defined by the attributes of this object.
        @param src_vertex: the source vertex. Visual properties are defined
          by the attributes of this object.
        @param dest_vertex: the source vertex. Visual properties are defined
          by the attributes of this object.
        """
        ...
    
    def get_label_position(self, edge, src_vertex, dest_vertex): # -> tuple[tuple[Any, Any], tuple[TextAlignment, TextAlignment]]:
        """Returns the position where the label of an edge should be drawn. the
        default implementation returns the midpoint of the edge and an alignment
        that tries to avoid overlapping the label with the edge.

        @param edge: the edge to be drawn. visual properties of the edge
          are defined by the attributes of this object.
        @param src_vertex: the source vertex. visual properties are given
          again as attributes.
        @param dest_vertex: the target vertex. visual properties are given
          again as attributes.
        @return: a tuple containing two more tuples: the desired position of the
          label and the desired alignment of the label, where the position is
          given as c{(x, y)} and the alignment is given as c{(horizontal, vertical)}.
          members of the alignment tuple are taken from constants in the
          l{textalignment} class.
        """
        ...
    
    def get_label_rotation(self, edge, src_vertex, dest_vertex): # -> float:
        """Get the rotation angle of the label to align with the edge.

        @param edge: the edge to be drawn. visual properties of the edge
          are defined by the attributes of this object.
        @param src_vertex: the source vertex. visual properties are given
          again as attributes.
        @param dest_vertex: the target vertex. visual properties are given
          again as attributes.
        @return: a float with the desired angle, in degrees (out of 360).
        """
        ...
    


class AbstractVertexDrawer(AbstractDrawer):
    """Abstract vertex drawer object from which all concrete vertex drawer
    implementations are derived."""
    def __init__(self, palette, layout) -> None:
        """Constructs the vertex drawer and associates it to the given
        palette.

        @param palette: the palette that can be used to map integer
                        color indices to colors when drawing vertices
        @param layout:  the layout of the vertices in the graph being drawn
        """
        ...
    
    @abstractmethod
    def draw(self, visual_vertex, vertex, coords):
        """Draws the given vertex.

        @param visual_vertex: object specifying the visual properties of the
            vertex. Its structure is defined by the VisualVertexBuilder of the
            L{CairoGraphDrawer}; see its source code.
        @param vertex: the raw igraph vertex being drawn
        @param coords: the X and Y coordinates of the vertex as specified by the
            layout algorithm, scaled into the bounding box.
        """
        ...
    


class AbstractGraphDrawer(AbstractDrawer):
    """Abstract class that serves as a base class for anything that
    draws an igraph.Graph.
    """
    @abstractmethod
    def draw(self, graph, *args, **kwds):
        """Abstract method, must be implemented in derived classes."""
        ...
    
    @staticmethod
    def ensure_layout(layout, graph=...): # -> Layout:
        """Helper method that ensures that I{layout} is an instance
        of L{Layout}. If it is not, the method will try to convert
        it to a L{Layout} according to the following rules:

          - If I{layout} is a string, it is assumed to be a name
            of an igraph layout, and it will be passed on to the
            C{layout} method of the given I{graph} if I{graph} is
            not C{None}.

          - If I{layout} is C{None} and I{graph} has a "layout"
            attribute, call this same function with the value of that
            attribute.

          - If I{layout} is C{None} and I{graph} does not have a "layout"
            attribute, the C{layout} method of I{graph} will be invoked
            with no parameters, which will call the default layout algorithm.

          - Otherwise, I{layout} will be passed on to the constructor
            of L{Layout}. This handles lists of lists, lists of tuples
            and such.

        If I{layout} is already a L{Layout} instance, it will still
        be copied and a copy will be returned. This is because graph
        drawers are allowed to transform the layout for their purposes,
        and we don't want the transformation to propagate back to the
        caller.
        """
        ...
    


