"""
This type stub file was generated by pyright.
"""

from abc import ABCMeta

"""
Color handling functions.
"""
__all__ = ("Palette", "GradientPalette", "AdvancedGradientPalette", "RainbowPalette", "PrecalculatedPalette", "ClusterColoringPalette", "color_name_to_rgb", "color_name_to_rgba", "hsv_to_rgb", "hsva_to_rgba", "hsl_to_rgb", "hsla_to_rgba", "rgb_to_hsv", "rgba_to_hsva", "rgb_to_hsl", "rgba_to_hsla", "palettes", "default_edge_colors", "known_colors")
class Palette(metaclass=ABCMeta):
    """Base class of color palettes.

    Color palettes are mappings that assign integers from the range
    0..M{n-1} to colors (4-tuples). M{n} is called the size or length
    of the palette. C{igraph} comes with a number of predefined palettes,
    so this class is useful for you only if you want to define your
    own palette. This can be done by subclassing this class and implementing
    the L{Palette._get} method as necessary.

    Palettes can also be used as lists or dicts, for the C{__getitem__}
    method is overridden properly to call L{Palette.get}.
    """
    def __init__(self, n) -> None:
        ...
    
    def clear_cache(self): # -> None:
        """Clears the result cache.

        The return values of L{Palette.get} are cached. Use this method
        to clear the cache.
        """
        ...
    
    def get(self, v): # -> tuple[Any, ...] | tuple[float | Any | str, ...]:
        """Returns the given color from the palette.

        Values are cached: if the specific value given has already been
        looked up, its value will be returned from the cache instead of
        calculating it again. Use L{Palette.clear_cache} to clear the cache
        if necessary.

        @note: you shouldn't override this method in subclasses, override
          L{_get} instead. If you override this method, lookups in the
          L{known_colors} dict won't work, so you won't be able to refer to
          colors by names or RGBA quadruplets, only by integer indices. The
          caching functionality will disappear as well. However,
          feel free to override this method if this is exactly the behaviour
          you want.

        @param v: the color to be retrieved. If it is an integer, it is
          passed to L{Palette._get} to be translated to an RGBA quadruplet.
          Otherwise it is passed to L{color_name_to_rgb()} to determine the
          RGBA values.

        @return: the color as an RGBA quadruplet"""
        ...
    
    def get_many(self, colors): # -> list[Any | tuple[Any, ...] | tuple[float | Any | str, ...]]:
        """Returns multiple colors from the palette.

        Values are cached: if the specific value given has already been
        looked upon, its value will be returned from the cache instead of
        calculating it again. Use L{Palette.clear_cache} to clear the cache
        if necessary.

        @param colors: the list of colors to be retrieved. The palette class
          tries to make an educated guess here: if it is not possible to
          interpret the value you passed here as a list of colors, the
          class will simply try to interpret it as a single color by
          forwarding the value to L{Palette.get}.
        @return: the colors as a list of RGBA quadruplets. The result will
          be a list even if you passed a single color index or color name.
        """
        ...
    
    __getitem__ = ...
    @property
    def length(self): # -> Any:
        """Returns the number of colors in this palette"""
        ...
    
    def __len__(self): # -> Any:
        """Returns the number of colors in this palette"""
        ...
    
    def __plot__(self, backend, context, *args, **kwds): # -> None:
        """Plots the colors of the palette on the given Cairo context/mpl Axes

        Supported keywork arguments in both Cairo and matplotlib are:

          - C{orientation}: the orientation of the palette. Must be one of
            the following values: C{left-right}, C{bottom-top}, C{right-left}
            or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},
            C{vertical} = C{bottom-top}, C{lr} = C{left-right},
            C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.
            The default is C{left-right}.

        Additional supported keyword arguments in Cairo are:

          - C{border_width}: line width of the border shown around the palette.
            If zero or negative, the border is turned off. Default is C{1}.

          - C{grid_width}: line width of the grid that separates palette cells.
            If zero or negative, the grid is turned off. The grid is also
            turned off if the size of a cell is less than three times the given
            line width. Default is C{0}.  Fractional widths are also allowed.

        Keyword arguments in matplotlib are passes to Axes.imshow.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class GradientPalette(Palette):
    """Base class for gradient palettes

    Gradient palettes contain a gradient between two given colors.

    Example:

      >>> pal = GradientPalette("red", "blue", 5)
      >>> pal.get(0)
      (1.0, 0.0, 0.0, 1.0)
      >>> pal.get(2)
      (0.5, 0.0, 0.5, 1.0)
      >>> pal.get(4)
      (0.0, 0.0, 1.0, 1.0)
    """
    def __init__(self, color1, color2, n=...) -> None:
        """Creates a gradient palette.

        @param color1: the color where the gradient starts.
        @param color2: the color where the gradient ends.
        @param n: the number of colors in the palette.
        """
        ...
    


class AdvancedGradientPalette(Palette):
    """Advanced gradient that consists of more than two base colors.

    Example:

      >>> pal = AdvancedGradientPalette(["red", "black", "blue"], n=9)
      >>> pal.get(2)
      (0.5, 0.0, 0.0, 1.0)
      >>> pal.get(7)
      (0.0, 0.0, 0.75, 1.0)
    """
    def __init__(self, colors, indices=..., n=...) -> None:
        """Creates an advanced gradient palette

        @param colors: the colors in the gradient.
        @param indices: the color indices belonging to the given colors. If
          C{None}, the colors are distributed equidistantly
        @param n: the total number of colors in the palette
        """
        ...
    


class RainbowPalette(Palette):
    """A palette that varies the hue of the colors along a scale.

    Colors in a rainbow palette all have the same saturation, value and
    alpha components, while the hue is varied between two given extremes
    linearly. This palette has the advantage that it wraps around nicely
    if the hue is varied between zero and one (which is the default).

    Example:

        >>> pal = RainbowPalette(n=120)
        >>> pal.get(0)
        (1.0, 0.0, 0.0, 1.0)
        >>> pal.get(20)
        (1.0, 1.0, 0.0, 1.0)
        >>> pal.get(40)
        (0.0, 1.0, 0.0, 1.0)
        >>> pal = RainbowPalette(n=120, s=1, v=0.5, alpha=0.75)
        >>> pal.get(60)
        (0.0, 0.5, 0.5, 0.75)
        >>> pal.get(80)
        (0.0, 0.0, 0.5, 0.75)
        >>> pal.get(100)
        (0.5, 0.0, 0.5, 0.75)
        >>> pal = RainbowPalette(n=120)
        >>> pal2 = RainbowPalette(n=120, start=0.5, end=0.5)
        >>> pal.get(60) == pal2.get(0)
        True
        >>> pal.get(90) == pal2.get(30)
        True

    This palette was modeled after the C{rainbow} command of R.
    """
    def __init__(self, n=..., s=..., v=..., start=..., end=..., alpha=...) -> None:
        """Creates a rainbow palette.

        @param n: the number of colors in the palette.
        @param s: the saturation of the colors in the palette.
        @param v: the value component of the colors in the palette.
        @param start: the hue at which the rainbow begins (between 0 and 1).
        @param end: the hue at which the rainbow ends (between 0 and 1).
        @param alpha: the alpha component of the colors in the palette.
        """
        ...
    


class PrecalculatedPalette(Palette):
    """A palette that returns colors from a pre-calculated list of colors"""
    def __init__(self, items) -> None:
        """Creates the palette backed by the given list. The list must contain
        RGBA quadruplets or color names, which will be resolved first by
        L{color_name_to_rgba()}. Anything that is understood by
        L{color_name_to_rgba()} is OK here."""
        ...
    


class ClusterColoringPalette(PrecalculatedPalette):
    """A palette suitable for coloring vertices when plotting a clustering.

    This palette tries to make sure that the colors are easily distinguishable.
    This is achieved by using a set of base colors and their lighter and darker
    variants, depending on the number of elements in the palette.

    When the desired size of the palette is less than or equal to the number of
    base colors (denoted by M{n}), only the bsae colors will be used. When the
    size of the palette is larger than M{n} but less than M{2*n}, the base colors
    and their lighter variants will be used. Between M{2*n} and M{3*n}, the
    base colors and their lighter and darker variants will be used. Above M{3*n},
    more darker and lighter variants will be generated, but this makes the individual
    colors less and less distinguishable.
    """
    def __init__(self, n) -> None:
        ...
    


def clamp(value, min_value, max_value):
    """Clamps the given value between min and max"""
    ...

def color_name_to_rgb(color, palette=...):
    """Converts a color given in one of the supported color formats to
    R-G-B values.

    This is done by calling L{color_name_to_rgba} and then throwing away
    the alpha value.

    @see: color_name_to_rgba for more details about what formats are
      understood by this function.
    """
    ...

def color_name_to_rgba(color, palette=...):
    """Converts a color given in one of the supported color formats to
    R-G-B-A values.

    Examples:

      >>> color_name_to_rgba("red")
      (1.0, 0.0, 0.0, 1.0)
      >>> color_name_to_rgba("#ff8000") == (1.0, 128/255.0, 0.0, 1.0)
      True
      >>> color_name_to_rgba("#ff800080") == (1.0, 128/255.0, 0.0, 128/255.0)
      True
      >>> color_name_to_rgba("#08f") == (0.0, 136/255.0, 1.0, 1.0)
      True
      >>> color_name_to_rgba("rgb(100%, 50%, 0%)")
      (1.0, 0.5, 0.0, 1.0)
      >>> color_name_to_rgba("rgba(100%, 50%, 0%, 25%)")
      (1.0, 0.5, 0.0, 0.25)
      >>> color_name_to_rgba("hsla(120, 100%, 50%, 0.5)")
      (0.0, 1.0, 0.0, 0.5)
      >>> color_name_to_rgba("hsl(60, 100%, 50%)")
      (1.0, 1.0, 0.0, 1.0)
      >>> color_name_to_rgba("hsv(60, 100%, 100%)")
      (1.0, 1.0, 0.0, 1.0)

    @param color: the color to be converted in one of the following formats:
      - B{CSS3 color specification}: C{#rrggbb}, C{#rgb}, C{#rrggbbaa}, C{#rgba},
        C{rgb(red, green, blue)}, C{rgba(red, green, blue, alpha)},
        C{hsl(hue, saturation, lightness)}, C{hsla(hue, saturation, lightness, alpha)},
        C{hsv(hue, saturation, value)} and C{hsva(hue, saturation, value, alpha)}
        where the components are given as hexadecimal numbers in the first four
        cases and as decimals or percentages (0%-100%) in the remaining cases.
        Red, green and blue components are between 0 and 255; hue is between 0
        and 360; saturation, lightness and value is between 0 and 100; alpha is
        between 0 and 1.
      - B{Valid HTML color names}, i.e. those that are present in the HTML 4.0
        specification
      - B{Valid X11 color names}, see U{http://en.wikipedia.org/wiki/X11_color_names}
      - B{Red-green-blue components} given separately in either a comma-, slash- or
        whitespace-separated string or a list or a tuple, in the range of 0-255.
        An alpha value of 255 (maximal opacity) will be assumed.
      - B{Red-green-blue-alpha components} given separately in either a comma-, slash-
        or whitespace-separated string or a list or a tuple, in the range of 0-255
      - B{A single palette index} given either as a string or a number. Uses
        the palette given in the C{palette} parameter of the method call.
    @param palette: the palette to be used if a single number is passed to
      the method. Must be an instance of L{colors.Palette}.

    @return: the RGBA values corresponding to the given color in a 4-tuple.
      Since these colors are primarily used by Cairo routines, the tuples
      contain floats in the range 0.0-1.0
    """
    ...

def color_to_html_format(color): # -> str:
    """Formats a color given as a 3-tuple or 4-tuple in HTML format.

    The HTML format is simply given by C{#rrggbbaa}, where C{rr} gives
    the red component in hexadecimal format, C{gg} gives the green
    component C{bb} gives the blue component and C{gg} gives the
    alpha level. The alpha level is optional.
    """
    ...

def darken(color, ratio=...): # -> tuple[Any, Any, Any, Any]:
    """Creates a darker version of a color given by an RGB triplet.

    This is done by mixing the original color with black using the given
    ratio. A ratio of 1.0 will yield a completely black color, a ratio
    of 0.0 will yield the original color. The alpha values are left intact.
    """
    ...

def hsla_to_rgba(h, s, l, alpha=...): # -> tuple[Any, Any, Any, float]:
    """Converts a color given by its HSLA coordinates (hue, saturation,
    lightness, alpha) to RGBA coordinates.

    Each of the HSLA coordinates must be in the range [0, 1].
    """
    ...

def hsl_to_rgb(h, s, l): # -> tuple[Any, Any, Any]:
    """Converts a color given by its HSL coordinates (hue, saturation,
    lightness) to RGB coordinates.

    Each of the HSL coordinates must be in the range [0, 1].
    """
    ...

def hsva_to_rgba(h, s, v, alpha=...): # -> tuple[Any, Any, Any, float]:
    """Converts a color given by its HSVA coordinates (hue, saturation,
    value, alpha) to RGB coordinates.

    Each of the HSVA coordinates must be in the range [0, 1].
    """
    ...

def hsv_to_rgb(h, s, v): # -> tuple[Any, Any, Any]:
    """Converts a color given by its HSV coordinates (hue, saturation,
    value) to RGB coordinates.

    Each of the HSV coordinates must be in the range [0, 1].
    """
    ...

def rgba_to_hsla(r, g, b, alpha=...): # -> tuple[float, float, float, float] | tuple[Any, float, float, float]:
    """Converts a color given by its RGBA coordinates to HSLA coordinates
    (hue, saturation, lightness, alpha).

    Each of the RGBA coordinates must be in the range [0, 1].
    """
    ...

def rgba_to_hsva(r, g, b, alpha=...): # -> tuple[float, float, float, float] | tuple[Any, float, float, float]:
    """Converts a color given by its RGBA coordinates to HSVA coordinates
    (hue, saturation, value, alpha).

    Each of the RGBA coordinates must be in the range [0, 1].
    """
    ...

def rgb_to_hsl(r, g, b): # -> tuple[float, float, float] | tuple[Any, float, float]:
    """Converts a color given by its RGB coordinates to HSL coordinates
    (hue, saturation, lightness).

    Each of the RGB coordinates must be in the range [0, 1].
    """
    ...

def rgb_to_hsv(r, g, b): # -> tuple[float, float, float] | tuple[Any, float, float]:
    """Converts a color given by its RGB coordinates to HSV coordinates
    (hue, saturation, value).

    Each of the RGB coordinates must be in the range [0, 1].
    """
    ...

def lighten(color, ratio=...): # -> tuple[Any, Any, Any, Any]:
    """Creates a lighter version of a color given by an RGB triplet.

    This is done by mixing the original color with white using the given
    ratio. A ratio of 1.0 will yield a completely white color, a ratio
    of 0.0 will yield the original color.
    """
    ...

default_edge_colors = ...
known_colors = ...
palettes = ...
