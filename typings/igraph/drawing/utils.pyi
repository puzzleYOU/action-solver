"""
This type stub file was generated by pyright.
"""

from typing import NamedTuple

"""
Utility classes for drawing routines.
"""
__all__ = ("BoundingBox", "Point", "Rectangle", "calculate_corner_radii", "euclidean_distance", "evaluate_cubic_bezier", "get_bezier_control_points_for_curved_edge", "intersect_bezier_curve_and_circle", "str_to_orientation", "autocurve")
class Rectangle:
    """Class representing a rectangle."""
    __slots__ = ...
    def __init__(self, *args) -> None:
        """Creates a rectangle.

        The corners of the rectangle can be specified by either a tuple
        (four items, two for each corner, respectively), four separate numbers
        (X and Y coordinates for each corner) or two separate numbers (width
        and height, the upper left corner is assumed to be at (0,0))"""
        ...
    
    @property
    def coords(self): # -> tuple[Any | float, Any, Any | float, Any]:
        """The coordinates of the corners.

        The coordinates are returned as a 4-tuple in the following order:
        left edge, top edge, right edge, bottom edge.
        """
        ...
    
    @coords.setter
    def coords(self, coords): # -> None:
        """Sets the coordinates of the corners.

        @param coords: a 4-tuple with the coordinates of the corners
        """
        ...
    
    @property
    def width(self): # -> float:
        """The width of the rectangle"""
        ...
    
    @width.setter
    def width(self, value): # -> None:
        """Sets the width of the rectangle by adjusting the right edge."""
        ...
    
    @property
    def height(self):
        """The height of the rectangle"""
        ...
    
    @height.setter
    def height(self, value): # -> None:
        """Sets the height of the rectangle by adjusting the bottom edge."""
        ...
    
    @property
    def left(self): # -> float:
        """The X coordinate of the left side of the box"""
        ...
    
    @left.setter
    def left(self, value): # -> None:
        """Sets the X coordinate of the left side of the box"""
        ...
    
    @property
    def right(self): # -> float:
        """The X coordinate of the right side of the box"""
        ...
    
    @right.setter
    def right(self, value): # -> None:
        """Sets the X coordinate of the right side of the box"""
        ...
    
    @property
    def top(self):
        """The Y coordinate of the top edge of the box"""
        ...
    
    @top.setter
    def top(self, value): # -> None:
        """Sets the Y coordinate of the top edge of the box"""
        ...
    
    @property
    def bottom(self):
        """The Y coordinate of the bottom edge of the box"""
        ...
    
    @bottom.setter
    def bottom(self, value): # -> None:
        """Sets the Y coordinate of the bottom edge of the box"""
        ...
    
    @property
    def midx(self): # -> float:
        """The X coordinate of the center of the box"""
        ...
    
    @midx.setter
    def midx(self, value): # -> None:
        """Moves the center of the box to the given X coordinate"""
        ...
    
    @property
    def midy(self):
        """The Y coordinate of the center of the box"""
        ...
    
    @midy.setter
    def midy(self, value): # -> None:
        """Moves the center of the box to the given Y coordinate"""
        ...
    
    @property
    def shape(self): # -> tuple[Any | float, Any]:
        """The shape of the rectangle (width, height)"""
        ...
    
    @shape.setter
    def shape(self, shape): # -> None:
        """Sets the shape of the rectangle (width, height)."""
        ...
    
    def contract(self, margins): # -> Self:
        """Contracts the rectangle by the given margins.

        @return: a new L{Rectangle} object.
        """
        ...
    
    def expand(self, margins): # -> Self:
        """Expands the rectangle by the given margins.

        @return: a new L{Rectangle} object.
        """
        ...
    
    def isdisjoint(self, other):
        """Returns C{True} if the two rectangles have no intersection.

        Example::

            >>> r1 = Rectangle(10, 10, 30, 30)
            >>> r2 = Rectangle(20, 20, 50, 50)
            >>> r3 = Rectangle(70, 70, 90, 90)
            >>> r1.isdisjoint(r2)
            False
            >>> r2.isdisjoint(r1)
            False
            >>> r1.isdisjoint(r3)
            True
            >>> r3.isdisjoint(r1)
            True
        """
        ...
    
    def isempty(self): # -> Literal[False]:
        """Returns C{True} if the rectangle is empty (i.e. it has zero
        width and height).

        Example::

            >>> r1 = Rectangle(10, 10, 30, 30)
            >>> r2 = Rectangle(70, 70, 90, 90)
            >>> r1.isempty()
            False
            >>> r2.isempty()
            False
            >>> r1.intersection(r2).isempty()
            True
        """
        ...
    
    def intersection(self, other): # -> Rectangle:
        """Returns the intersection of this rectangle with another.

        Example::

            >>> r1 = Rectangle(10, 10, 30, 30)
            >>> r2 = Rectangle(20, 20, 50, 50)
            >>> r3 = Rectangle(70, 70, 90, 90)
            >>> r1.intersection(r2)
            Rectangle(20.0, 20.0, 30.0, 30.0)
            >>> r2 & r1
            Rectangle(20.0, 20.0, 30.0, 30.0)
            >>> r2.intersection(r1) == r1.intersection(r2)
            True
            >>> r1.intersection(r3)
            Rectangle(0.0, 0.0, 0.0, 0.0)
        """
        ...
    
    __and__ = ...
    def translate(self, dx, dy): # -> None:
        """Translates the rectangle in-place.

        Example:

            >>> r = Rectangle(10, 20, 50, 70)
            >>> r.translate(30, -10)
            >>> r
            Rectangle(40.0, 10.0, 80.0, 60.0)

        @param dx: the X coordinate of the translation vector
        @param dy: the Y coordinate of the translation vector
        """
        ...
    
    def union(self, other): # -> Rectangle:
        """Returns the union of this rectangle with another.

        The resulting rectangle is the smallest rectangle that contains both
        rectangles.

        Example::

            >>> r1 = Rectangle(10, 10, 30, 30)
            >>> r2 = Rectangle(20, 20, 50, 50)
            >>> r3 = Rectangle(70, 70, 90, 90)
            >>> r1.union(r2)
            Rectangle(10.0, 10.0, 50.0, 50.0)
            >>> r2 | r1
            Rectangle(10.0, 10.0, 50.0, 50.0)
            >>> r2.union(r1) == r1.union(r2)
            True
            >>> r1.union(r3)
            Rectangle(10.0, 10.0, 90.0, 90.0)
        """
        ...
    
    __or__ = ...
    def __ior__(self, other): # -> Self:
        """Expands this rectangle to include itself and another completely while
        still being as small as possible.

        Example::

            >>> r1 = Rectangle(10, 10, 30, 30)
            >>> r2 = Rectangle(20, 20, 50, 50)
            >>> r3 = Rectangle(70, 70, 90, 90)
            >>> r1 |= r2
            >>> r1
            Rectangle(10.0, 10.0, 50.0, 50.0)
            >>> r1 |= r3
            >>> r1
            Rectangle(10.0, 10.0, 90.0, 90.0)
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __bool__(self): # -> Literal[True]:
        ...
    
    def __hash__(self) -> int:
        ...
    


class BoundingBox(Rectangle):
    """Class representing a bounding box (a rectangular area) that
    encloses some objects."""
    def __ior__(self, other): # -> Self:
        """Replaces this bounding box with the union of itself and
        another.

        Example::

            >>> box1 = BoundingBox(10, 20, 50, 60)
            >>> box2 = BoundingBox(70, 40, 100, 90)
            >>> box1 |= box2
            >>> print(box1)
            BoundingBox(10.0, 20.0, 100.0, 90.0)
        """
        ...
    
    def __or__(self, other): # -> Self:
        """Takes the union of this bounding box with another.

        The result is a bounding box which encloses both bounding
        boxes.

        Example::

            >>> box1 = BoundingBox(10, 20, 50, 60)
            >>> box2 = BoundingBox(70, 40, 100, 90)
            >>> box1 | box2
            BoundingBox(10.0, 20.0, 100.0, 90.0)
        """
        ...
    


class FakeModule:
    """Fake module that raises an exception for everything"""
    def __init__(self, message) -> None:
        """Constructor.

        @param message: message to print in exceptions raised from this module
        """
        ...
    
    def __getattr__(self, _):
        ...
    
    def __call__(self, _):
        ...
    
    def __setattr__(self, key, value): # -> None:
        ...
    


class Point(NamedTuple("_Point", [("x", float), ("y", float)])):
    """Class representing a point on the 2D plane."""
    def __add__(self, other): # -> _Point:
        """Adds the coordinates of a point to another one"""
        ...
    
    def __sub__(self, other): # -> _Point:
        """Subtracts the coordinates of a point to another one"""
        ...
    
    def __mul__(self, scalar): # -> _Point:
        """Multiplies the coordinates by a scalar"""
        ...
    
    __rmul__ = ...
    def __div__(self, scalar): # -> _Point:
        """Divides the coordinates by a scalar"""
        ...
    
    def as_polar(self): # -> tuple[int, float]:
        """Returns the polar coordinate representation of the point.

        @return: the radius and the angle in a tuple.
        """
        ...
    
    def distance(self, other):
        """Returns the distance of the point from another one.

        Example:

            >>> p1 = Point(5, 7)
            >>> p2 = Point(8, 3)
            >>> p1.distance(p2)
            5.0
        """
        ...
    
    def interpolate(self, other, ratio=...): # -> _Point:
        """Linearly interpolates between the coordinates of this point and
        another one.

        @param  other:  the other point
        @param  ratio:  the interpolation ratio between 0 and 1. Zero will
          return this point, 1 will return the other point.
        """
        ...
    
    def length(self): # -> Any:
        """Returns the length of the vector pointing from the origin to this
        point."""
        ...
    
    def normalized(self): # -> _Point:
        """Normalizes the coordinates of the point s.t. its length will be 1
        after normalization. Returns the normalized point."""
        ...
    
    def sq_length(self): # -> float:
        """Returns the squared length of the vector pointing from the origin
        to this point."""
        ...
    
    def towards(self, other, distance=...): # -> Self | _Point:
        """Returns the point that is at a given distance from this point
        towards another one."""
        ...
    
    @classmethod
    def FromPolar(cls, radius, angle): # -> Self:
        """Constructs a point from polar coordinates.

        C{radius} is the distance of the point from the origin; C{angle} is the
        angle between the X axis and the vector pointing to the point from
        the origin.
        """
        ...
    


def calculate_corner_radii(points, corner_radius): # -> list[Any]:
    """Given a list of points and a desired corner radius, returns a list
    containing proposed corner radii for each of the points such that it is
    ensured that the corner radius at a point is never larger than half of
    the minimum distance between the point and its neighbors.
    """
    ...

def euclidean_distance(x1, y1, x2, y2): # -> float:
    """Computes the Euclidean distance between points (x1,y1) and (x2,y2)."""
    ...

def evaluate_cubic_bezier(x0, y0, x1, y1, x2, y2, x3, y3, t): # -> tuple[Any, Any]:
    """Evaluates the Bezier curve from point (x0,y0) to (x3,y3)
    via control points (x1,y1) and (x2,y2) at t. t is typically in the range
    [0; 1] such that 0 returns (x0, y0) and 1 returns (x3, y3).
    """
    ...

def get_bezier_control_points_for_curved_edge(x1, y1, x2, y2, curvature): # -> tuple[tuple[Any, Any], tuple[Any, Any]]:
    """Helper function that calculates the Bezier control points for a
    curved edge that goes from (x1, y1) to (x2, y2).
    """
    ...

def intersect_bezier_curve_and_circle(x0, y0, x1, y1, x2, y2, x3, y3, radius, max_iter=...): # -> tuple[Any, Any]:
    """Binary search solver for finding the intersection of a Bezier curve
    and a circle centered at the curve's end point.

    Returns the x, y coordinates of the intersection point.
    """
    ...

def str_to_orientation(value, reversed_horizontal=..., reversed_vertical=...): # -> Literal['lr', 'rl', 'tb', 'bt']:
    """Tries to interpret a string as an orientation value.

    The following basic values are understood: ``left-right``, ``bottom-top``,
    ``right-left``, ``top-bottom``. Possible aliases are:

      - ``horizontal``, ``horiz``, ``h`` and ``lr`` for ``left-right``

      - ``vertical``, ``vert``, ``v`` and ``tb`` for top-bottom.

      - ``lr`` for ``left-right``.

      - ``rl`` for ``right-left``.

    ``reversed_horizontal`` reverses the meaning of ``horizontal``, ``horiz``
    and ``h`` to ``rl`` (instead of ``lr``); similarly, ``reversed_vertical``
    reverses the meaning of ``vertical``, ``vert`` and ``v`` to ``bt``
    (instead of ``tb``).

    Returns one of ``lr``, ``rl``, ``tb`` or ``bt``, or throws ``ValueError``
    if the string cannot be interpreted as an orientation.
    """
    ...

def autocurve(graph, attribute=..., default=...): # -> None:
    """Calculates curvature values for each of the edges in the graph to make
    sure that multiple edges are shown properly on a graph plot.

    This function checks the multiplicity of each edge in the graph and
    assigns curvature values (numbers between -1 and 1, corresponding to
    CCW (-1), straight (0) and CW (1) curved edges) to them. The assigned
    values are either stored in an edge attribute or returned as a list,
    depending on the value of the I{attribute} argument.

    @param graph: the graph on which the calculation will be run
    @param attribute: the name of the edge attribute to save the curvature
      values to. The default value is C{curved}, which is the name of the
      edge attribute the default graph plotter checks to decide whether an
      edge should be curved on the plot or not. If I{attribute} is C{None},
      the result will not be stored.
    @param default: the default curvature for single edges. Zero means that
      single edges will be straight. If you want single edges to be curved
      as well, try passing 0.5 or -0.5 here.
    @return: the list of curvature values if I{attribute} is C{None},
      otherwise C{None}.
    """
    ...

