"""
This type stub file was generated by pyright.
"""

"""Classes related to graph clustering."""
class Clustering:
    """Class representing a clustering of an arbitrary ordered set.

    This is now used as a base for L{VertexClustering}, but it might be
    useful for other purposes as well.

    Members of an individual cluster can be accessed by the C{[]} operator:

      >>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])
      >>> cl[0]
      [0, 1, 2, 3]

    The membership vector can be accessed by the C{membership} property:

      >>> cl.membership
      [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2]

    The number of clusters can be retrieved by the C{len} function:

      >>> len(cl)
      3

    You can iterate over the clustering object as if it were a regular list
    of clusters:

      >>> for cluster in cl:
      ...     print(" ".join(str(idx) for idx in cluster))
      ...
      0 1 2 3
      4 5 6
      7 8 9 10

    If you need all the clusters at once as lists, you can simply convert
    the clustering object to a list:

      >>> cluster_list = list(cl)
      >>> print(cluster_list)
      [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9, 10]]
    """
    def __init__(self, membership, params=...) -> None:
        """Constructor.

        @param membership: the membership list -- that is, the cluster
          index in which each element of the set belongs to.
        @param params: additional parameters to be stored in this
          object's dictionary.
        """
        ...
    
    def __getitem__(self, idx): # -> list[int]:
        """Returns the members of the specified cluster.

        @param idx: the index of the cluster
        @return: the members of the specified cluster as a list
        @raise IndexError: if the index is out of bounds"""
        ...
    
    def __iter__(self): # -> Iterator[list[Any]]:
        """Iterates over the clusters in this clustering.

        This method will return a generator that generates the clusters
        one by one."""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of clusters.

        @return: the number of clusters
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def as_cover(self): # -> Cover:
        """Returns a L{Cover} that contains the same clusters as this clustering."""
        ...
    
    def compare_to(self, other, *args, **kwds):
        """Compares this clustering to another one using some similarity or
        distance metric.

        This is a convenience method that simply calls L{compare_communities}
        with the two clusterings as arguments. Any extra positional or keyword
        argument is also forwarded to L{compare_communities}."""
        ...
    
    @property
    def membership(self): # -> list[Any]:
        """Returns the membership vector."""
        ...
    
    @property
    def n(self): # -> int:
        """Returns the number of elements covered by this clustering."""
        ...
    
    def size(self, idx): # -> int:
        """Returns the size of a given cluster.

        @param idx: the cluster in which we are interested.
        """
        ...
    
    def sizes(self, *args): # -> list[Any] | list[int]:
        """Returns the size of given clusters.

        The indices are given as positional arguments. If there are no
        positional arguments, the function will return the sizes of all clusters.
        """
        ...
    
    def size_histogram(self, bin_width=...): # -> Histogram:
        """Returns the histogram of cluster sizes.

        @param bin_width: the bin width of the histogram
        @return: a L{Histogram} object
        """
        ...
    
    def summary(self, verbosity=..., width=...): # -> str:
        """Returns the summary of the clustering.

        The summary includes the number of items and clusters, and also the
        list of members for each of the clusters if the verbosity is nonzero.

        @param verbosity: determines whether the cluster members should be
          printed. Zero verbosity prints the number of items and clusters only.
        @return: the summary of the clustering as a string.
        """
        ...
    


class VertexClustering(Clustering):
    """The clustering of the vertex set of a graph.

    This class extends L{Clustering} by linking it to a specific L{Graph} object
    and by optionally storing the modularity score of the clustering.
    It also provides some handy methods like getting the subgraph corresponding
    to a cluster and such.

    @note: since this class is linked to a L{Graph}, destroying the graph by the
      C{del} operator does not free the memory occupied by the graph if there
      exists a L{VertexClustering} that references the L{Graph}.
    """
    _default_palette = ...
    def __init__(self, graph, membership=..., modularity=..., params=..., modularity_params=...) -> None:
        """Creates a clustering object for a given graph.

        @param graph: the graph that will be associated to the clustering
        @param membership: the membership list. The length of the list must
          be equal to the number of vertices in the graph. If C{None}, every
          vertex is assumed to belong to the same cluster.
        @param modularity: the modularity score of the clustering. If C{None},
          it will be calculated when needed.
        @param params: additional parameters to be stored in this object.
        @param modularity_params: arguments that should be passed to
          L{Graph.modularity} when the modularity is (re)calculated. If the
          original graph was weighted, you should pass a dictionary
          containing a C{weight} key with the appropriate value here.
        """
        ...
    
    @classmethod
    def FromAttribute(cls, graph, attribute, intervals=..., params=...): # -> Self:
        """Creates a vertex clustering based on the value of a vertex attribute.

        Vertices having the same attribute will correspond to the same cluster.

        @param graph: the graph on which we are working
        @param attribute: name of the attribute on which the clustering
            is based.
        @param intervals: for numeric attributes, you can either pass a single
            number or a list of numbers here. A single number means that the
            vertices will be put in bins of that width and vertices ending up
            in the same bin will be in the same cluster. A list of numbers
            specify the bin positions explicitly; e.g., C{[10, 20, 30]} means
            that there will be four categories: vertices with the attribute
            value less than 10, between 10 and 20, between 20 and 30 and over 30.
            Intervals are closed from the left and open from the right.
        @param params: additional parameters to be stored in this object.

        @return: a new VertexClustering object
        """
        ...
    
    def as_cover(self): # -> VertexCover:
        """Returns a L{VertexCover} that contains the same clusters as this
        clustering."""
        ...
    
    def cluster_graph(self, combine_vertices=..., combine_edges=...):
        """Returns a graph where each cluster is contracted into a single
        vertex.

        In the resulting graph, vertex M{i} represents cluster M{i} in this
        clustering. Vertex M{i} and M{j} will be connected if there was
        at least one connected vertex pair M{(a, b)} in the original graph such
        that vertex M{a} was in cluster M{i} and vertex M{b} was in cluster
        M{j}.

        @param combine_vertices: specifies how to derive the attributes of
          the vertices in the new graph from the attributes of the old ones.
          See L{Graph.contract_vertices()<igraph._igraph.GraphBase.contract_vertices>}
          for more details.
        @param combine_edges: specifies how to derive the attributes of the
          edges in the new graph from the attributes of the old ones. See
          L{Graph.simplify()<igraph._igraph.GraphBase.simplify>} for more details.
          If you specify C{False} here, edges will not be combined, and the
          number of edges between the vertices representing the original
          clusters will be equal to the number of edges between the members of
          those clusters in the original graph.

        @return: the new graph.
        """
        ...
    
    def crossing(self): # -> list[Any]:
        """Returns a boolean vector where element M{i} is C{True} iff edge
        M{i} lies between clusters, C{False} otherwise."""
        ...
    
    @property
    def modularity(self): # -> None:
        """Returns the modularity score"""
        ...
    
    q = ...
    @property
    def graph(self): # -> Any:
        """Returns the graph belonging to this object"""
        ...
    
    def recalculate_modularity(self):
        """Recalculates the stored modularity value.

        This method must be called before querying the modularity score of the
        clustering through the class member C{modularity} or C{q} if the
        graph has been modified (edges have been added or removed) since the
        creation of the L{VertexClustering} object.

        @return: the new modularity score
        """
        ...
    
    def subgraph(self, idx):
        """Get the subgraph belonging to a given cluster.

        Precondition: the vertex set of the graph hasn't been modified since the
        moment the cover was constructed.

        @param idx: the cluster index
        @return: a copy of the subgraph
        """
        ...
    
    def subgraphs(self): # -> list[Any]:
        """Gets all the subgraphs belonging to each of the clusters.

        Precondition: the vertex set of the graph hasn't been modified since the
        moment the cover was constructed.

        @return: a list containing copies of the subgraphs
        """
        ...
    
    def giant(self):
        """Returns the largest cluster of the clustered graph.

        The largest cluster is a cluster for which no larger cluster exists in
        the clustering. It may also be known as the I{giant community} if the
        clustering represents the result of a community detection function.

        Precondition: the vertex set of the graph hasn't been modified since the
        moment the cover was constructed.

        @note: there can be multiple largest clusters, this method will return
          the copy of an arbitrary one if there are multiple largest clusters.

        @return: a copy of the largest cluster.
        """
        ...
    
    def __plot__(self, backend, context, *args, **kwds):
        """Plots the clustering to the given Cairo context or matplotlib Axes.

        This is done by calling L{Graph.__plot__()} with the same arguments, but
        coloring the graph vertices according to the current clustering (unless
        overridden by the C{vertex_color} argument explicitly).

        This method understands all the positional and keyword arguments that
        are understood by L{Graph.__plot__()}, only the differences will be
        highlighted here:

          - C{mark_groups}: whether to highlight some of the vertex groups by
            colored polygons. Besides the values accepted by L{Graph.__plot__}
            (i.e., a dict mapping colors to vertex indices, a list containing
            lists of vertex indices, or C{False}), the following are also
            accepted:

              - C{True}: all the groups will be highlighted, the colors matching
                the corresponding color indices from the current palette
                (see the C{palette} keyword argument of L{Graph.__plot__}).

              - A dict mapping cluster indices or tuples of vertex indices to
                color names.  The given clusters or vertex groups will be
                highlighted by the given colors.

              - A list of cluster indices. This is equivalent to passing a
                dict mapping numeric color indices from the current palette
                to cluster indices; therefore, the cluster referred to by element
                I{i} of the list will be highlighted by color I{i} from the
                palette.

            The value of the C{plotting.mark_groups} configuration key is also
            taken into account here; if that configuration key is C{True} and
            C{mark_groups} is not given explicitly, it will automatically be set
            to C{True}.

            In place of lists of vertex indices, you may also use L{VertexSeq}
            instances.

            In place of color names, you may also use color indices into the
            current palette. C{None} as a color name will mean that the
            corresponding group is ignored.

          - C{palette}: the palette used to resolve numeric color indices to RGBA
            values. By default, this is an instance of L{ClusterColoringPalette}.

        @see: L{Graph.__plot__()} for more supported keyword arguments.
        """
        ...
    


class Dendrogram:
    """The hierarchical clustering (dendrogram) of some dataset.

    A hierarchical clustering means that we know not only the way the
    elements are separated into groups, but also the exact history of
    how individual elements were joined into larger subgroups.

    This class internally represents the hierarchy by a matrix with n rows
    and 2 columns -- or more precisely, a list of lists of size 2. This is
    exactly the same as the original format used by C{igraph}'s C core.
    The M{i}th row of the matrix contains the indices of the two clusters
    being joined in time step M{i}. The joint group will be represented by
    the ID M{n+i}, with M{i} starting from one. The ID of the joint group
    will be referenced in the upcoming steps instead of any of its individual
    members. So, IDs less than or equal to M{n} (where M{n} is the number of
    rows in the matrix) mean the original members of the dataset (with ID
    from 0 to M{n}), while IDs up from M{n+1} mean joint groups. As an
    example, take a look at the dendrogram and the internal representation of
    a given clustering of five nodes::

      0 -+
         |
      1 -+-+
           |
      2 ---+-+        <====>   [[0, 1], [3, 4], [2, 5], [6, 7]]
             |
      3 -+   |
         |   |
      4 -+---+---
    """
    def __init__(self, merges) -> None:
        """Creates a hierarchical clustering.

        @param merges: the merge history either in matrix or tuple format"""
        ...
    
    def __str__(self) -> str:
        ...
    
    def format(self, format=...):
        """Formats the dendrogram in a foreign format.

        Currently only the Newick format is supported.

        Example:

            >>> d = Dendrogram([(2, 3), (0, 1), (4, 5)])
            >>> d.format()
            '((2,3)4,(0,1)5)6;'
            >>> d.names = list("ABCDEFG")
            >>> d.format()
            '((C,D)E,(A,B)F)G;'
        """
        ...
    
    def summary(self, verbosity=..., max_leaf_count=...): # -> str:
        """Returns the summary of the dendrogram.

        The summary includes the number of leafs and branches, and also an
        ASCII art representation of the dendrogram unless it is too large.

        @param verbosity: determines whether the ASCII representation of the
          dendrogram should be printed. Zero verbosity prints only the number
          of leafs and branches.
        @param max_leaf_count: the maximal number of leafs to print in the
          ASCII representation. If the dendrogram has more leafs than this
          limit, the ASCII representation will not be printed even if the
          verbosity is larger than or equal to 1.
        @return: the summary of the dendrogram as a string.
        """
        ...
    
    def __plot__(self, backend, context, *args, **kwds): # -> None:
        """Draws the dendrogram on the given Cairo context or matplotlib Axes.

        Supported keyword arguments are:

          - C{orientation}: the orientation of the dendrogram. Must be one of
            the following values: C{left-right}, C{bottom-top}, C{right-left}
            or C{top-bottom}. Individual elements are always placed at the
            former edge and merges are performed towards the latter edge.
            Possible aliases: C{horizontal} = C{left-right},
            C{vertical} = C{bottom-top}, C{lr} = C{left-right},
            C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.
            The default is C{left-right}.

        """
        ...
    
    @property
    def merges(self): # -> list[tuple[Any, ...]]:
        """Returns the performed merges in matrix format"""
        ...
    
    @property
    def names(self): # -> list[Any] | None:
        """Returns the names of the nodes in the dendrogram"""
        ...
    
    @names.setter
    def names(self, items): # -> None:
        """Sets the names of the nodes in the dendrogram"""
        ...
    


class VertexDendrogram(Dendrogram):
    """The dendrogram resulting from the hierarchical clustering of the
    vertex set of a graph."""
    def __init__(self, graph, merges, optimal_count=..., modularity_params=...) -> None:
        """Creates a dendrogram object for a given graph.

        @param graph: the graph that will be associated to the clustering
        @param merges: the merges performed given in matrix form.
        @param optimal_count: the optimal number of clusters where the
          dendrogram should be cut. This is a hint usually provided by the
          clustering algorithm that produces the dendrogram. C{None} means
          that such a hint is not available; the optimal count will then be
          selected based on the modularity in such a case.
        @param modularity_params: arguments that should be passed to
          L{Graph.modularity} when the modularity is (re)calculated. If the
          original graph was weighted, you should pass a dictionary
          containing a C{weight} key with the appropriate value here.
        """
        ...
    
    def as_clustering(self, n=...): # -> VertexClustering:
        """Cuts the dendrogram at the given level and returns a corresponding
        L{VertexClustering} object.

        @param n: the desired number of clusters. Merges are replayed from the
          beginning until the membership vector has exactly M{n} distinct elements
          or until there are no more recorded merges, whichever happens first.
          If C{None}, the optimal count hint given by the clustering algorithm
          will be used If the optimal count was not given either, it will be
          calculated by selecting the level where the modularity is maximal.
        @return: a new L{VertexClustering} object.
        """
        ...
    
    @property
    def optimal_count(self): # -> int:
        """Returns the optimal number of clusters for this dendrogram.

        If an optimal count hint was given at construction time, this
        property simply returns the hint. If such a count was not given,
        this method calculates the optimal number of clusters by maximizing
        the modularity along all the possible cuts in the dendrogram.
        """
        ...
    
    @optimal_count.setter
    def optimal_count(self, value): # -> None:
        ...
    
    def __plot__(self, backend, context, *args, **kwds): # -> None:
        """Draws the vertex dendrogram on the given Cairo context or matplotlib Axes

        See L{Dendrogram.__plot__} for the list of supported keyword
        arguments."""
        class VisualVertexBuilder(AttributeCollectorBase):
            ...
        
        
    


class Cover:
    """Class representing a cover of an arbitrary ordered set.

    Covers are similar to clusterings, but each element of the set may
    belong to more than one cluster in a cover, and elements not belonging
    to any cluster are also allowed.

    L{Cover} instances provide a similar API as L{Clustering} instances;
    for instance, iterating over a L{Cover} will iterate over the clusters
    just like with a regular L{Clustering} instance. However, they are not
    derived from each other or from a common superclass, and there might
    be functions that exist only in one of them or the other.

    Clusters of an individual cover can be accessed by the C{[]} operator:

      >>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])
      >>> cl[0]
      [0, 1, 2, 3]

    The membership vector can be accessed by the C{membership} property.
    Note that contrary to L{Clustering} instances, the membership vector
    will contain lists that contain the cluster indices each item belongs
    to:

      >>> cl.membership
      [[0, 2], [0, 2], [0, 1], [0, 1], [1], [], [2]]

    The number of clusters can be retrieved by the C{len} function:

      >>> len(cl)
      3

    You can iterate over the cover as if it were a regular list of
    clusters:

      >>> for cluster in cl:
      ...     print(" ".join(str(idx) for idx in cluster))
      ...
      0 1 2 3
      2 3 4
      0 1 6

    If you need all the clusters at once as lists, you can simply convert
    the cover to a list:

      >>> cluster_list = list(cl)
      >>> print(cluster_list)
      [[0, 1, 2, 3], [2, 3, 4], [0, 1, 6]]

    L{Clustering} objects can readily be converted to L{Cover} objects
    using the constructor:

      >>> clustering = Clustering([0, 0, 0, 0, 1, 1, 1, 2, 2, 2])
      >>> cover = Cover(clustering)
      >>> list(clustering) == list(cover)
      True
    """
    def __init__(self, clusters, n=...) -> None:
        """Constructs a cover with the given clusters.

        @param clusters: the clusters in this cover, as a list or iterable.
          Each cluster is specified by a list or tuple that contains the
          IDs of the items in this cluster. IDs start from zero.

        @param n: the total number of elements in the set that is covered
          by this cover. If it is less than the number of unique elements
          found in all the clusters, we will simply use the number of unique
          elements, so it is safe to leave this at zero. You only have to
          specify this parameter if there are some elements that are covered
          by none of the clusters.
        """
        ...
    
    def __getitem__(self, index): # -> list[Any]:
        """Returns the cluster with the given index."""
        ...
    
    def __iter__(self): # -> Iterator[list[Any]]:
        """Iterates over the clusters in this cover."""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of clusters in this cover."""
        ...
    
    def __str__(self) -> str:
        """Returns a string representation of the cover."""
        ...
    
    @property
    def membership(self): # -> list[list[Any]]:
        """Returns the membership vector of this cover.

        The membership vector of a cover covering I{n} elements is a list of
        length I{n}, where element I{i} contains the cluster indices of the
        I{i}th item.
        """
        ...
    
    @property
    def n(self): # -> int:
        """Returns the number of elements in the set covered by this cover."""
        ...
    
    def size(self, idx): # -> int:
        """Returns the size of a given cluster.

        @param idx: the cluster in which we are interested.
        """
        ...
    
    def sizes(self, *args): # -> list[int]:
        """Returns the size of given clusters.

        The indices are given as positional arguments. If there are no
        positional arguments, the function will return the sizes of all clusters.
        """
        ...
    
    def size_histogram(self, bin_width=...): # -> Histogram:
        """Returns the histogram of cluster sizes.

        @param bin_width: the bin width of the histogram
        @return: a L{Histogram} object
        """
        ...
    
    def summary(self, verbosity=..., width=...): # -> str:
        """Returns the summary of the cover.

        The summary includes the number of items and clusters, and also the
        list of members for each of the clusters if the verbosity is nonzero.

        @param verbosity: determines whether the cluster members should be
          printed. Zero verbosity prints the number of items and clusters only.
        @return: the summary of the cover as a string.
        """
        ...
    


class VertexCover(Cover):
    """The cover of the vertex set of a graph.

    This class extends L{Cover} by linking it to a specific L{Graph} object.
    It also provides some handy methods like getting the subgraph corresponding
    to a cluster and such.

    @note: since this class is linked to a L{Graph}, destroying the graph by the
      C{del} operator does not free the memory occupied by the graph if there
      exists a L{VertexCover} that references the L{Graph}.
    """
    def __init__(self, graph, clusters=...) -> None:
        """Creates a cover object for a given graph.

        @param graph: the graph that will be associated to the cover
        @param clusters: the list of clusters. If C{None}, it is assumed
          that there is only a single cluster that covers the whole graph.
        """
        ...
    
    def crossing(self): # -> list[Any]:
        """Returns a boolean vector where element M{i} is C{True} iff edge
        M{i} lies between clusters, C{False} otherwise."""
        ...
    
    @property
    def graph(self): # -> Any:
        """Returns the graph belonging to this object"""
        ...
    
    def subgraph(self, idx):
        """Get the subgraph belonging to a given cluster.

        Precondition: the vertex set of the graph hasn't been modified since the
        moment the cover was constructed.

        @param idx: the cluster index
        @return: a copy of the subgraph
        """
        ...
    
    def subgraphs(self): # -> list[Any]:
        """Gets all the subgraphs belonging to each of the clusters.

        Precondition: the vertex set of the graph hasn't been modified since the
        moment the cover was constructed.

        @return: a list containing copies of the subgraphs
        """
        ...
    
    def __plot__(self, backend, context, *args, **kwds):
        """Plots the cover to the given Cairo context or matplotlib Axes.

        This is done by calling L{Graph.__plot__()} with the same arguments, but
        drawing nice colored blobs around the vertex groups.

        This method understands all the positional and keyword arguments that
        are understood by L{Graph.__plot__()}, only the differences will be
        highlighted here:

          - C{mark_groups}: whether to highlight the vertex clusters by
            colored polygons. Besides the values accepted by L{Graph.__plot__}
            (i.e., a dict mapping colors to vertex indices, a list containing
            lists of vertex indices, or C{False}), the following are also
            accepted:

              - C{True}: all the clusters will be highlighted, the colors matching
                the corresponding color indices from the current palette
                (see the C{palette} keyword argument of L{Graph.__plot__}).

              - A dict mapping cluster indices or tuples of vertex indices to
                color names.  The given clusters or vertex groups will be
                highlighted by the given colors.

              - A list of cluster indices. This is equivalent to passing a
                dict mapping numeric color indices from the current palette
                to cluster indices; therefore, the cluster referred to by element
                I{i} of the list will be highlighted by color I{i} from the
                palette.

            The value of the C{plotting.mark_groups} configuration key is also
            taken into account here; if that configuration key is C{True} and
            C{mark_groups} is not given explicitly, it will automatically be set
            to C{True}.

            In place of lists of vertex indices, you may also use L{VertexSeq}
            instances.

            In place of color names, you may also use color indices into the
            current palette. C{None} as a color name will mean that the
            corresponding group is ignored.

          - C{palette}: the palette used to resolve numeric color indices to RGBA
            values. By default, this is an instance of L{ClusterColoringPalette}.

        @see: L{Graph.__plot__()} for more supported keyword arguments.
        """
        ...
    


class CohesiveBlocks(VertexCover):
    """The cohesive block structure of a graph.

    Instances of this type are created by
    L{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>}. See the
    documentation of L{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>}
    for an explanation of what cohesive blocks are.

    This class provides a few more methods that make handling of cohesive
    block structures easier.
    """
    def __init__(self, graph, blocks=..., cohesion=..., parent=...) -> None:
        """Constructs a new cohesive block structure for the given graph.

        If any of I{blocks}, I{cohesion} or I{parent} is C{None}, all the
        arguments will be ignored and
        L{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>} will be called
        to calculate the cohesive blocks. Otherwise, these three variables
        should describe the *result* of a cohesive block structure calculation.
        Chances are that you never have to construct L{CohesiveBlocks}
        instances directly, just use
        L{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>}.

        @param graph: the graph itself
        @param blocks: a list containing the blocks; each block is described
          as a list containing vertex IDs.
        @param cohesion: the cohesion of each block. The length of this list
          must be equal to the length of I{blocks}.
        @param parent: the parent block of each block. Negative values or
          C{None} mean that there is no parent block for that block. There
          should be only one parent block, which covers the entire graph.
        @see: Graph.cohesive_blocks()
        """
        ...
    
    def cohesion(self, idx):
        """Returns the cohesion of the group with the given index."""
        ...
    
    def cohesions(self):
        """Returns the list of cohesion values for each group."""
        ...
    
    def hierarchy(self): # -> Graph:
        """Returns a new graph that describes the hierarchical relationships
        between the groups.

        The new graph will be a directed tree; an edge will point from
        vertex M{i} to vertex M{j} if group M{i} is a superset of group M{j}.
        In other words, the edges point downwards.
        """
        ...
    
    def max_cohesion(self, idx): # -> int:
        """Finds the maximum cohesion score among all the groups that contain
        the given vertex."""
        ...
    
    def max_cohesions(self):
        """For each vertex in the graph, returns the maximum cohesion score
        among all the groups that contain the vertex."""
        ...
    
    def parent(self, idx):
        """Returns the parent group index of the group with the given index
        or C{None} if the given group is the root."""
        ...
    
    def parents(self):
        """Returns the list of parent group indices for each group or C{None}
        if the given group is the root."""
        ...
    
    def __plot__(self, backend, context, *args, **kwds):
        """Plots the cohesive block structure to the given Cairo context or
        matplotlib Axes.

        Since a L{CohesiveBlocks} instance is also a L{VertexCover}, keyword
        arguments accepted by L{VertexCover.__plot__()} are also accepted here.
        The only difference is that the vertices are colored according to their
        maximal cohesions by default, and groups are marked by colored blobs
        except the last group which encapsulates the whole graph.

        See the documentation of L{VertexCover.__plot__()} for more details.
        """
        ...
    


def compare_communities(comm1, comm2, method=..., remove_none=...):
    """Compares two community structures using various distance measures.

    For measures involving entropies (e.g., the variation of information metric),
    igraph uses natural logarithms.

    B{References}

      - Meila M: Comparing clusterings by the variation of information. In:
        Scholkopf B, Warmuth MK (eds). Learning Theory and Kernel Machines: 16th
        Annual Conference on Computational Learning Theory and 7th Kernel
        Workship, COLT/Kernel 2003, Washington, DC, USA. Lecture Notes in Computer
        Science, vol. 2777, Springer, 2003. ISBN: 978-3-540-40720-1.
      - Danon L, Diaz-Guilera A, Duch J, Arenas A: Comparing community structure
        identification. I{J Stat Mech} P09008, 2005.
      - van Dongen S: Performance criteria for graph clustering and Markov
        cluster experiments. Technical Report INS-R0012, National Research
        Institute for Mathematics and Computer Science in the Netherlands,
        Amsterdam, May 2000.
      - Rand WM: Objective criteria for the evaluation of clustering
        methods. I{J Am Stat Assoc} 66(336):846-850, 1971.
      - Hubert L and Arabie P: Comparing partitions. I{Journal of
        Classification} 2:193-218, 1985.

    @param comm1: the first community structure as a membership list or
      as a L{Clustering} object.
    @param comm2: the second community structure as a membership list or
      as a L{Clustering} object.
    @param method: the measure to use. C{"vi"} or C{"meila"} means the
      variation of information metric of Meila (2003), C{"nmi"} or C{"danon"}
      means the normalized mutual information as defined by Danon et al. (2005),
      C{"split-join"} means the split-join distance of van Dongen (2000),
      C{"rand"} means the Rand index of Rand (1971), C{"adjusted_rand"}
      means the adjusted Rand index of Hubert and Arabie (1985).
    @param remove_none: whether to remove C{None} entries from the membership
      lists. This is handy if your L{Clustering} object was constructed using
      L{VertexClustering.FromAttribute} using an attribute which was not defined
      for all the vertices. If C{remove_none} is C{False}, a C{None} entry in
      either C{comm1} or C{comm2} will result in an exception. If C{remove_none}
      is C{True}, C{None} values are filtered away and only the remaining lists
      are compared.

    @return: the calculated measure.
    """
    ...

def split_join_distance(comm1, comm2, remove_none=...):
    """Calculates the split-join distance between two community structures.

    The split-join distance is a distance measure defined on the space of
    partitions of a given set. It is the sum of the projection distance of
    one partition from the other and vice versa, where the projection
    number of A from B is if calculated as follows:

      1. For each set in A, find the set in B with which it has the
         maximal overlap, and take note of the size of the overlap.

      2. Take the sum of the maximal overlap sizes for each set in A.

      3. Subtract the sum from M{n}, the number of elements in the
         partition.

    Note that the projection distance is asymmetric, that's why it has to be
    calculated in both directions and then added together.  This function
    returns the projection distance of C{comm1} from C{comm2} and the
    projection distance of C{comm2} from C{comm1}, and returns them in a pair.
    The actual split-join distance is the sum of the two distances. The reason
    why it is presented this way is that one of the elements being zero then
    implies that one of the partitions is a subpartition of the other (and if
    it is close to zero, then one of the partitions is close to being a
    subpartition of the other).

    B{Reference}: van Dongen S: Performance criteria for graph clustering and
    Markov cluster experiments. Technical Report INS-R0012, National Research
    Institute for Mathematics and Computer Science in the Netherlands,
    Amsterdam, May 2000.

    @param comm1: the first community structure as a membership list or
      as a L{Clustering} object.
    @param comm2: the second community structure as a membership list or
      as a L{Clustering} object.
    @param remove_none: whether to remove C{None} entries from the membership
      lists. This is handy if your L{Clustering} object was constructed using
      L{VertexClustering.FromAttribute} using an attribute which was not defined
      for all the vertices. If C{remove_none} is C{False}, a C{None} entry in
      either C{comm1} or C{comm2} will result in an exception. If C{remove_none}
      is C{True}, C{None} values are filtered away and only the remaining lists
      are compared.

    @return: the projection distance of C{comm1} from C{comm2} and vice versa
      in a tuple. The split-join distance is the sum of the two.

    @see: L{compare_communities()} with C{method = "split-join"} if you are
      not interested in the individual projection distances but only the
      sum of them.
    """
    ...

