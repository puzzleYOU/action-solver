"""
This type stub file was generated by pyright.
"""

__all__ = ("__iadd__", "__add__", "__and__", "__isub__", "__sub__", "__mul__", "__or__", "_disjoint_union", "_union", "_intersection")
def __iadd__(graph, other): # -> _NotImplementedType:
    """In-place addition (disjoint union).

    @see: L{__add__}
    """
    ...

def __add__(graph, other): # -> _NotImplementedType:
    """Copies the graph and extends the copy depending on the type of
    the other object given.

    @param other: if it is an integer, the copy is extended by the given
      number of vertices. If it is a string, the copy is extended by a
      single vertex whose C{name} attribute will be equal to the given
      string. If it is a tuple with two elements, the copy
      is extended by a single edge. If it is a list of tuples, the copy
      is extended by multiple edges. If it is a L{Graph}, a disjoint
      union is performed.
    """
    ...

def __and__(graph, other): # -> _NotImplementedType:
    """Graph intersection operator.

    @param other: the other graph to take the intersection with.
    @return: the intersected graph.
    """
    ...

def __isub__(graph, other): # -> _NotImplementedType:
    """In-place subtraction (difference).

    @see: L{__sub__}"""
    ...

def __sub__(graph, other): # -> _NotImplementedType:
    """Removes the given object(s) from the graph

    @param other: if it is an integer, removes the vertex with the given
      ID from the graph (note that the remaining vertices will get
      re-indexed!). If it is a tuple, removes the given edge. If it is
      a graph, takes the difference of the two graphs. Accepts
      lists of integers or lists of tuples as well, but they can't be
      mixed! Also accepts L{Edge} and L{EdgeSeq} objects.
    """
    ...

def __mul__(graph, other): # -> Graph | _NotImplementedType:
    """Copies exact replicas of the original graph an arbitrary number of
    times.

    @param other: if it is an integer, multiplies the graph by creating the
      given number of identical copies and taking the disjoint union of
      them.
    """
    ...

def __or__(graph, other): # -> _NotImplementedType:
    """Graph union operator.

    @param other: the other graph to take the union with.
    @return: the union graph.
    """
    ...

