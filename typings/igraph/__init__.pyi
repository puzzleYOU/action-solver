"""
This type stub file was generated by pyright.
"""

import os
import sys
from igraph._igraph import ADJ_DIRECTED, ADJ_LOWER, ADJ_MAX, ADJ_MIN, ADJ_PLUS, ADJ_UNDIRECTED, ADJ_UPPER, ALL, ARPACKOptions, BFSIter, BLISS_F, BLISS_FL, BLISS_FLM, BLISS_FM, BLISS_FS, BLISS_FSM, DFSIter, Edge, GET_ADJACENCY_BOTH, GET_ADJACENCY_LOWER, GET_ADJACENCY_UPPER, GraphBase, IN, InternalError, OUT, REWIRING_SIMPLE, REWIRING_SIMPLE_LOOPS, STAR_IN, STAR_MUTUAL, STAR_OUT, STAR_UNDIRECTED, STRONG, TRANSITIVITY_NAN, TRANSITIVITY_ZERO, TREE_IN, TREE_OUT, TREE_UNDIRECTED, Vertex, WEAK, __igraph_version__, arpack_options as default_arpack_options, community_to_membership, convex_hull, is_bigraphical, is_degree_sequence, is_graphical, is_graphical_degree_sequence, set_progress_handler, set_random_number_generator, set_status_handler, umap_compute_weights
from igraph.adjacency import _get_adjacency, _get_adjacency_sparse, _get_adjlist, _get_biadjacency, _get_inclist
from igraph.automorphisms import _count_automorphisms_vf2, _get_automorphisms_vf2
from igraph.basic import _add_edge, _add_edges, _add_vertex, _add_vertices, _as_directed, _as_undirected, _clear, _delete_edges
from igraph.bipartite import _bipartite_projection, _bipartite_projection_size, _maximum_bipartite_matching
from igraph.community import _community_edge_betweenness, _community_fastgreedy, _community_infomap, _community_label_propagation, _community_leading_eigenvector, _community_leiden, _community_multilevel, _community_optimal_modularity, _community_spinglass, _community_walktrap, _k_core, _modularity
from igraph.clustering import Clustering, CohesiveBlocks, Cover, Dendrogram, VertexClustering, VertexCover, VertexDendrogram, _biconnected_components, _clusters, _cohesive_blocks, _connected_components, compare_communities, split_join_distance
from igraph.cut import Cut, Flow, _all_st_cuts, _all_st_mincuts, _gomory_hu_tree, _maxflow, _mincut, _st_mincut
from igraph.configuration import Configuration, init as init_configuration
from igraph.drawing import BoundingBox, CairoGraphDrawer, DefaultGraphDrawer, MatplotlibGraphDrawer, Plot, Point, Rectangle, plot
from igraph.drawing.colors import AdvancedGradientPalette, ClusterColoringPalette, GradientPalette, Palette, PrecalculatedPalette, RainbowPalette, color_name_to_rgb, color_name_to_rgba, hsl_to_rgb, hsla_to_rgba, hsv_to_rgb, hsva_to_rgba, known_colors, palettes, rgb_to_hsl, rgb_to_hsv, rgba_to_hsla, rgba_to_hsva
from igraph.drawing.graph import __plot__ as _graph_plot
from igraph.drawing.utils import autocurve
from igraph.datatypes import DyadCensus, Matrix, TriadCensus, UniqueIdGenerator
from igraph.formula import construct_graph_from_formula
from igraph.io import _format_mapping
from igraph.io.files import _construct_graph_from_adjacency_file, _construct_graph_from_dimacs_file, _construct_graph_from_file, _construct_graph_from_graphmlz_file, _construct_graph_from_pickle_file, _construct_graph_from_picklez_file, _write_graph_to_adjacency_file, _write_graph_to_dimacs_file, _write_graph_to_file, _write_graph_to_graphmlz_file, _write_graph_to_pickle_file, _write_graph_to_picklez_file
from igraph.io.objects import _construct_graph_from_dataframe, _construct_graph_from_dict_dict, _construct_graph_from_dict_list, _construct_graph_from_list_dict, _construct_graph_from_tuple_list, _export_edge_dataframe, _export_graph_to_dict_dict, _export_graph_to_dict_list, _export_graph_to_list_dict, _export_graph_to_tuple_list, _export_vertex_dataframe
from igraph.io.adjacency import _construct_graph_from_adjacency, _construct_graph_from_weighted_adjacency
from igraph.io.libraries import _construct_graph_from_graph_tool, _construct_graph_from_networkx, _export_graph_to_graph_tool, _export_graph_to_networkx
from igraph.io.random import _construct_random_geometric_graph
from igraph.io.bipartite import _construct_bipartite_graph, _construct_bipartite_graph_from_adjacency, _construct_full_bipartite_graph, _construct_random_bipartite_graph
from igraph.io.images import _write_graph_to_svg
from igraph.layout import Layout, _3d_version_for, _layout, _layout_auto, _layout_mapping, _layout_method_wrapper, _layout_sugiyama
from igraph.matching import Matching
from igraph.operators import disjoint_union, intersection, operator_method_registry as _operator_method_registry, union
from igraph.seq import EdgeSeq, VertexSeq, _add_proxy_methods
from igraph.statistics import FittedPowerLaw, Histogram, RunningMean, mean, median, percentile, power_law_fit, quantile
from igraph.structural import _degree_distribution, _indegree, _outdegree, _pagerank, _shortest_paths
from igraph.summary import GraphSummary, summary
from igraph.utils import deprecated, numpy_to_contiguous_memoryview, rescale
from igraph.version import __version__, __version_info__

"""
igraph library.
"""
__license__ = ...
class Graph(GraphBase):
    """Generic graph.

    This class is built on top of L{GraphBase}, so the order of the
    methods in the generated API documentation is a little bit obscure:
    inherited methods come after the ones implemented directly in the
    subclass. L{Graph} provides many functions that L{GraphBase} does not,
    mostly because these functions are not speed critical and they were
    easier to implement in Python than in pure C. An example is the
    attribute handling in the constructor: the constructor of L{Graph}
    accepts three dictionaries corresponding to the graph, vertex and edge
    attributes while the constructor of L{GraphBase} does not. This extension
    was needed to make L{Graph} serializable through the C{pickle} module.
    L{Graph} also overrides some functions from L{GraphBase} to provide a
    more convenient interface; e.g., layout functions return a L{Layout}
    instance from L{Graph} instead of a list of coordinate pairs.

    Graphs can also be indexed by strings or pairs of vertex indices or vertex
    names.  When a graph is indexed by a string, the operation translates to
    the retrieval, creation, modification or deletion of a graph attribute:

      >>> g = Graph.Full(3)
      >>> g["name"] = "Triangle graph"
      >>> g["name"]
      'Triangle graph'
      >>> del g["name"]

    When a graph is indexed by a pair of vertex indices or names, the graph
    itself is treated as an adjacency matrix and the corresponding cell of
    the matrix is returned:

      >>> g = Graph.Full(3)
      >>> g.vs["name"] = ["A", "B", "C"]
      >>> g[1, 2]
      1
      >>> g["A", "B"]
      1
      >>> g["A", "B"] = 0
      >>> g.ecount()
      2

    Assigning values different from zero or one to the adjacency matrix will
    be translated to one, unless the graph is weighted, in which case the
    numbers will be treated as weights:

      >>> g.is_weighted()
      False
      >>> g["A", "B"] = 2
      >>> g["A", "B"]
      1
      >>> g.es["weight"] = 1.0
      >>> g.is_weighted()
      True
      >>> g["A", "B"] = 2
      >>> g["A", "B"]
      2
      >>> g.es["weight"]
      [1.0, 1.0, 2]
    """
    omega = ...
    alpha = ...
    shell_index = ...
    cut_vertices = ...
    blocks = ...
    evcent = ...
    vertex_disjoint_paths = ...
    edge_disjoint_paths = ...
    cohesion = ...
    adhesion = ...
    shortest_paths = ...
    shortest_paths_dijkstra = ...
    subgraph = ...
    def __init__(self, *args, **kwds) -> None:
        """__init__(n=0, edges=None, directed=False, graph_attrs=None,
        vertex_attrs=None, edge_attrs=None)

        Constructs a graph from scratch.

        @keyword n: the number of vertices. Can be omitted, the default is
          zero. Note that if the edge list contains vertices with indexes
          larger than or equal to M{n}, then the number of vertices will
          be adjusted accordingly.
        @keyword edges: the edge list where every list item is a pair of
          integers. If any of the integers is larger than M{n-1}, the number
          of vertices is adjusted accordingly. C{None} means no edges.
        @keyword directed: whether the graph should be directed
        @keyword graph_attrs: the attributes of the graph as a dictionary.
        @keyword vertex_attrs: the attributes of the vertices as a dictionary.
          The keys of the dictionary must be the names of the attributes; the
          values must be iterables with exactly M{n} items where M{n} is the
          number of vertices.
        @keyword edge_attrs: the attributes of the edges as a dictionary. The
          keys of the dictionary must be the names of the attributes; the values
          must be iterables with exactly M{m} items where M{m} is the number of
          edges.
        """
        ...
    
    from_networkx = ...
    to_networkx = ...
    from_graph_tool = ...
    to_graph_tool = ...
    Read_DIMACS = ...
    write_dimacs = ...
    Read_GraphMLz = ...
    write_graphmlz = ...
    Read_Pickle = ...
    write_pickle = ...
    Read_Picklez = ...
    write_picklez = ...
    Read_Adjacency = ...
    write_adjacency = ...
    write_svg = ...
    Read = ...
    Load = ...
    write = ...
    save = ...
    DictList = ...
    to_dict_list = ...
    TupleList = ...
    to_tuple_list = ...
    ListDict = ...
    to_list_dict = ...
    DictDict = ...
    to_dict_dict = ...
    Adjacency = ...
    Weighted_Adjacency = ...
    DataFrame = ...
    get_vertex_dataframe = ...
    get_edge_dataframe = ...
    Bipartite = ...
    Biadjacency = ...
    Full_Bipartite = ...
    Random_Bipartite = ...
    GRG = ...
    Formula = ...
    def __str__(self) -> str:
        """Returns a string representation of the graph.

        Behind the scenes, this method constructs a L{GraphSummary}
        instance and invokes its C{__str__} method with a verbosity of 1
        and attribute printing turned off.

        See the documentation of L{GraphSummary} for more details about the
        output.
        """
        ...
    
    def summary(self, verbosity=..., width=..., *args, **kwds): # -> str:
        """Returns the summary of the graph.

        The output of this method is similar to the output of the
        C{__str__} method. If I{verbosity} is zero, only the header line
        is returned (see C{__str__} for more details), otherwise the
        header line and the edge list is printed.

        Behind the scenes, this method constructs a L{GraphSummary}
        object and invokes its C{__str__} method.

        @param verbosity: if zero, only the header line is returned
          (see C{__str__} for more details), otherwise the header line
          and the full edge list is printed.
        @param width: the number of characters to use in one line.
          If C{None}, no limit will be enforced on the line lengths.
        @return: the summary of the graph.
        """
        ...
    
    def is_named(self): # -> bool:
        """Returns whether the graph is named.

        A graph is named if and only if it has a C{"name"} vertex attribute.
        """
        ...
    
    def is_weighted(self): # -> bool:
        """Returns whether the graph is weighted.

        A graph is weighted if and only if it has a C{"weight"} edge attribute.
        """
        ...
    
    @property
    def vs(self): # -> VertexSeq:
        """The vertex sequence of the graph"""
        ...
    
    @property
    def es(self): # -> EdgeSeq:
        """The edge sequence of the graph"""
        ...
    
    add_edge = ...
    add_edges = ...
    add_vertex = ...
    add_vertices = ...
    delete_edges = ...
    clear = ...
    as_directed = ...
    as_undirected = ...
    __iadd__ = ...
    __add__ = ...
    __and__ = ...
    __isub__ = ...
    __sub__ = ...
    __mul__ = ...
    __or__ = ...
    disjoint_union = ...
    union = ...
    intersection = ...
    get_adjacency = ...
    get_adjacency_sparse = ...
    get_adjlist = ...
    get_biadjacency = ...
    get_inclist = ...
    indegree = ...
    outdegree = ...
    degree_distribution = ...
    pagerank = ...
    all_st_cuts = ...
    all_st_mincuts = ...
    gomory_hu_tree = ...
    maxflow = ...
    mincut = ...
    st_mincut = ...
    biconnected_components = ...
    clusters = ...
    cohesive_blocks = ...
    connected_components = ...
    blocks = ...
    components = ...
    community_fastgreedy = ...
    community_infomap = ...
    community_leading_eigenvector = ...
    community_label_propagation = ...
    community_multilevel = ...
    community_optimal_modularity = ...
    community_edge_betweenness = ...
    community_spinglass = ...
    community_walktrap = ...
    k_core = ...
    community_leiden = ...
    modularity = ...
    layout = ...
    layout_auto = ...
    layout_sugiyama = ...
    __plot__ = ...
    maximum_bipartite_matching = ...
    bipartite_projection = ...
    bipartite_projection_size = ...
    count_automorphisms_vf2 = ...
    get_automorphisms_vf2 = ...
    def get_all_simple_paths(self, v, to=..., cutoff=..., mode=...): # -> list[Any]:
        """Calculates all the simple paths from a given node to some other nodes
        (or all of them) in a graph.

        A path is simple if its vertices are unique, i.e. no vertex is visited
        more than once.

        Note that potentially there are exponentially many paths between two
        vertices of a graph, especially if your graph is lattice-like. In this
        case, you may run out of memory when using this function.

        @param v: the source for the calculated paths
        @param to: a vertex selector describing the destination for the calculated
          paths. This can be a single vertex ID, a list of vertex IDs, a single
          vertex name, a list of vertex names or a L{VertexSeq} object. C{None}
          means all the vertices.
        @param cutoff: maximum length of path that is considered. If negative,
          paths of all lengths are considered.
        @param mode: the directionality of the paths. C{\"in\"} means to calculate
          incoming paths, C{\"out\"} means to calculate outgoing paths, C{\"all\"} means
          to calculate both ones.
        @return: all of the simple paths from the given node to every other
          reachable node in the graph in a list. Note that in case of mode=C{\"in\"},
          the vertices in a path are returned in reversed order!
        """
        ...
    
    def path_length_hist(self, directed=...): # -> Histogram:
        """Returns the path length histogram of the graph

        @param directed: whether to consider directed paths. Ignored for
          undirected graphs.
        @return: a L{Histogram} object. The object will also have an
          C{unconnected} attribute that stores the number of unconnected
          vertex pairs (where the second vertex can not be reached from
          the first one). The latter one will be of type long (and not
          a simple integer), since this can be I{very} large.
        """
        ...
    
    def dfs(self, vid, mode=...): # -> tuple[list[Any], list[Any]]:
        """Conducts a depth first search (DFS) on the graph.

        @param vid: the root vertex ID
        @param mode: either C{\"in\"} or C{\"out\"} or C{\"all\"}, ignored
          for undirected graphs.
        @return: a tuple with the following items:
           - The vertex IDs visited (in order)
           - The parent of every vertex in the DFS
        """
        ...
    
    def spanning_tree(self, weights=..., return_tree=...):
        """Calculates a minimum spanning tree for a graph.

        B{Reference}: Prim, R.C. Shortest connection networks and some
        generalizations. I{Bell System Technical Journal} 36:1389-1401, 1957.

        @param weights: a vector containing weights for every edge in
          the graph. C{None} means that the graph is unweighted.
        @param return_tree: whether to return the minimum spanning tree (when
          C{return_tree} is C{True}) or to return the IDs of the edges in
          the minimum spanning tree instead (when C{return_tree} is C{False}).
          The default is C{True} for historical reasons as this argument was
          introduced in igraph 0.6.
        @return: the spanning tree as a L{Graph} object if C{return_tree}
          is C{True} or the IDs of the edges that constitute the spanning
          tree if C{return_tree} is C{False}.
        """
        ...
    
    def dyad_census(self, *args, **kwds): # -> DyadCensus:
        """Calculates the dyad census of the graph.

        Dyad census means classifying each pair of vertices of a directed
        graph into three categories: mutual (there is an edge from I{a} to
        I{b} and also from I{b} to I{a}), asymmetric (there is an edge
        from I{a} to I{b} or from I{b} to I{a} but not the other way round)
        and null (there is no connection between I{a} and I{b}).

        B{Reference}: Holland, P.W. and Leinhardt, S. A Method for Detecting
        Structure in Sociometric Data. I{American Journal of Sociology}, 70,
        492-513, 1970.

        @return: a L{DyadCensus} object.
        """
        ...
    
    def triad_census(self, *args, **kwds): # -> TriadCensus:
        """Calculates the triad census of the graph.

        B{Reference}: Davis, J.A. and Leinhardt, S. The Structure of
        Positive Interpersonal Relations in Small Groups. In:
        J. Berger (Ed.), Sociological Theories in Progress, Volume 2,
        218-251. Boston: Houghton Mifflin (1972).

        @return: a L{TriadCensus} object.
        """
        ...
    
    def transitivity_avglocal_undirected(self, mode=..., weights=...): # -> float:
        """Calculates the average of the vertex transitivities of the graph.

        In the unweighted case, the transitivity measures the probability that
        two neighbors of a vertex are connected. In case of the average local
        transitivity, this probability is calculated for each vertex and then
        the average is taken. Vertices with less than two neighbors require
        special treatment, they will either be left out from the calculation
        or they will be considered as having zero transitivity, depending on
        the I{mode} parameter. The calculation is slightly more involved for
        weighted graphs; in this case, weights are taken into account according
        to the formula of Barrat et al (see the references).

        Note that this measure is different from the global transitivity
        measure (see L{transitivity_undirected()}) as it simply takes the
        average local transitivity across the whole network.

        B{References}

          - Watts DJ and Strogatz S: Collective dynamics of small-world
            networks. I{Nature} 393(6884):440-442, 1998.
          - Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A:
            The architecture of complex weighted networks. I{PNAS} 101, 3747
            (2004). U{https://arxiv.org/abs/cond-mat/0311416}.

        @param mode: defines how to treat vertices with degree less than two.
          If C{TRANSITIVITY_ZERO} or C{"zero"}, these vertices will have zero
          transitivity. If C{TRANSITIVITY_NAN} or C{"nan"}, these vertices
          will be excluded from the average.
        @param weights: edge weights to be used. Can be a sequence or iterable
          or even an edge attribute name.

        @see: L{transitivity_undirected()}, L{transitivity_local_undirected()}
        """
        ...
    
    def __bool__(self):
        """Returns True if the graph has at least one vertex, False otherwise."""
        ...
    
    def __coerce__(self, other): # -> tuple[Self, int | tuple[Any, ...] | list[Any] | str] | tuple[Self, Any] | tuple[Self, VertexSeq] | tuple[Self, EdgeSeq] | _NotImplementedType:
        """Coercion rules.

        This method is needed to allow the graph to react to additions
        with lists, tuples, integers, strings, vertices, edges and so on.
        """
        ...
    
    def __reduce__(self): # -> tuple[type[Self], tuple[Any, Any, Any, dict[Any, Any], dict[Any, Any], dict[Any, Any]], dict[str, Any]]:
        """Support for pickling."""
        ...
    
    __iter__ = ...
    __hash__ = ...
    @classmethod
    def Incidence(cls, *args, **kwds):
        """Deprecated alias to L{Graph.Biadjacency()}."""
        ...
    
    def are_connected(self, *args, **kwds):
        """Deprecated alias to L{Graph.are_adjacent()}."""
        ...
    
    def get_incidence(self, *args, **kwds):
        """Deprecated alias to L{Graph.get_biadjacency()}."""
        ...
    


def get_include(): # -> str:
    """Returns the folder that contains the C API headers of the Python
    interface of igraph."""
    ...

def read(filename, *args, **kwds): # -> Any:
    """Loads a graph from the given filename.

    This is just a convenience function, calls L{Graph.Read} directly.
    All arguments are passed unchanged to L{Graph.Read}

    @param filename: the name of the file to be loaded
    """
    ...

load = ...
def write(graph, filename, *args, **kwds):
    """Saves a graph to the given file.

    This is just a convenience function, calls L{Graph.write} directly.
    All arguments are passed unchanged to L{Graph.write}

    @param graph: the graph to be saved
    @param filename: the name of the file to be written
    """
    ...

save = ...
config: Configuration = ...
__all__ = ("config", "AdvancedGradientPalette", "BoundingBox", "CairoGraphDrawer", "ClusterColoringPalette", "Clustering", "CohesiveBlocks", "Configuration", "Cover", "Cut", "DefaultGraphDrawer", "Dendrogram", "DyadCensus", "Edge", "EdgeSeq", "FittedPowerLaw", "Flow", "GradientPalette", "Graph", "GraphBase", "GraphSummary", "Histogram", "InternalError", "Layout", "Matching", "MatplotlibGraphDrawer", "Matrix", "Palette", "Plot", "Point", "PrecalculatedPalette", "RainbowPalette", "Rectangle", "RunningMean", "TriadCensus", "UniqueIdGenerator", "Vertex", "VertexClustering", "VertexCover", "VertexDendrogram", "VertexSeq", "autocurve", "color_name_to_rgb", "color_name_to_rgba", "community_to_membership", "compare_communities", "convex_hull", "default_arpack_options", "disjoint_union", "get_include", "hsla_to_rgba", "hsl_to_rgb", "hsva_to_rgba", "hsv_to_rgb", "is_bigraphical", "is_degree_sequence", "is_graphical", "is_graphical_degree_sequence", "intersection", "known_colors", "load", "mean", "median", "palettes", "percentile", "plot", "power_law_fit", "quantile", "read", "rescale", "rgba_to_hsla", "rgb_to_hsl", "rgba_to_hsva", "rgb_to_hsv", "save", "set_progress_handler", "set_random_number_generator", "set_status_handler", "split_join_distance", "summary", "umap_compute_weights", "union", "write", "__igraph_version__", "__version__", "__version_info__", "ADJ_DIRECTED", "ADJ_LOWER", "ADJ_MAX", "ADJ_MIN", "ADJ_PLUS", "ADJ_UNDIRECTED", "ADJ_UPPER", "ALL", "ARPACKOptions", "BFSIter", "BLISS_F", "BLISS_FL", "BLISS_FLM", "BLISS_FM", "BLISS_FS", "BLISS_FSM", "DFSIter", "GET_ADJACENCY_BOTH", "GET_ADJACENCY_LOWER", "GET_ADJACENCY_UPPER", "IN", "OUT", "REWIRING_SIMPLE", "REWIRING_SIMPLE_LOOPS", "STAR_IN", "STAR_MUTUAL", "STAR_OUT", "STAR_UNDIRECTED", "STRONG", "TRANSITIVITY_NAN", "TRANSITIVITY_ZERO", "TREE_IN", "TREE_OUT", "TREE_UNDIRECTED", "WEAK")
