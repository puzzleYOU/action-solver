"""
This type stub file was generated by pyright.
"""

"""Additional auxiliary data types"""
__all__ = ("Matrix", )
class Matrix:
    """Simple matrix data type.

    Of course there are much more advanced matrix data types for Python (for
    instance, the C{ndarray} data type of Numeric Python) and this implementation
    does not want to compete with them. The only role of this data type is to
    provide a convenient interface for the matrices returned by the C{Graph}
    object (for instance, allow indexing with tuples in the case of adjacency
    matrices and so on).
    """
    def __init__(self, data=...) -> None:
        """Initializes a matrix.

        @param data: the elements of the matrix as a list of lists, or C{None} to
          create a 0x0 matrix.
        """
        ...
    
    @classmethod
    def Fill(cls, value, *args): # -> Self:
        """Creates a matrix filled with the given value

        @param value: the value to be used
        @keyword shape: the shape of the matrix. Can be a single integer,
          two integers or a tuple. If a single integer is
          given here, the matrix is assumed to be square-shaped.
        """
        ...
    
    @classmethod
    def Zero(cls, *args): # -> Self:
        """Creates a matrix filled with zeros.

        @keyword shape: the shape of the matrix. Can be a single integer,
          two integers or a tuple. If a single integer is
          given here, the matrix is assumed to be square-shaped.
        """
        ...
    
    @classmethod
    def Identity(cls, *args): # -> Self:
        """Creates an identity matrix.

        @keyword shape: the shape of the matrix. Can be a single integer,
          two integers or a tuple. If a single integer is
          given here, the matrix is assumed to be square-shaped.
        """
        ...
    
    data = ...
    @property
    def shape(self): # -> tuple[int, int]:
        """Returns the shape of the matrix as a tuple"""
        ...
    
    def __add__(self, other): # -> Self:
        """Adds the given value to the matrix.

        @param other: either a scalar or a matrix. Scalars will
          be added to each element of the matrix. Matrices will
          be added together elementwise.
        @return: the result matrix
        """
        ...
    
    def __eq__(self, other) -> bool:
        """Checks whether a given matrix is equal to another one"""
        ...
    
    def __getitem__(self, i): # -> list[Any] | Self | list[list[Any]]:
        """Returns a single item, a row or a column of the matrix

        @param i: if a single integer, returns the M{i}th row as a list. If a
          slice, returns the corresponding rows as another L{Matrix} object. If
          a 2-tuple, the first element of the tuple is used to select a row and
          the second is used to select a column.
        """
        ...
    
    def __hash__(self) -> int:
        """Returns a hash value for a matrix."""
        ...
    
    def __iadd__(self, other): # -> Self:
        """In-place addition of a matrix or scalar."""
        ...
    
    def __isub__(self, other): # -> Self:
        """In-place subtraction of a matrix or scalar."""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of rows in the matrix."""
        ...
    
    def __ne__(self, other) -> bool:
        """Checks whether a given matrix is not equal to another one"""
        ...
    
    def __setitem__(self, i, value): # -> None:
        """Sets a single item, a row or a column of the matrix

        @param i: if a single integer, sets the M{i}th row as a list. If a
          slice, sets the corresponding rows from another L{Matrix} object.
          If a 2-tuple, the first element of the tuple is used to select a row
          and the second is used to select a column.
        @param value: the new value
        """
        ...
    
    def __sub__(self, other): # -> Self:
        """Subtracts the given value from the matrix.

        @param other: either a scalar or a matrix. Scalars will
          be subtracted from each element of the matrix. Matrices will
          be subtracted together elementwise.
        @return: the result matrix
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __iter__(self): # -> Generator[list[Any], None, None]:
        """Support for iteration.

        This is actually implemented as a generator, so there is no need for a
        separate iterator class. The generator returns I{copies} of the rows in
        the matrix as lists to avoid messing around with the internals. Feel
        free to do anything with the copies, the changes won't be reflected in
        the original matrix."""
        ...
    
    def __plot__(self, backend, context, **kwds): # -> None:
        """Plots the matrix to the given Cairo context or matplotlib Axes.

        Besides the usual self-explanatory plotting parameters (C{context},
        C{bbox}, C{palette}), it accepts the following keyword arguments:

          - C{style}: the style of the plot. C{boolean} is useful for plotting
            matrices with boolean (C{True}/C{False} or 0/1) values: C{False}
            will be shown with a white box and C{True} with a black box.
            C{palette} uses the given palette to represent numbers by colors,
            the minimum will be assigned to palette color index 0 and the maximum
            will be assigned to the length of the palette. C{None} draws transparent
            cell backgrounds only. The default style is C{boolean} (but it may
            change in the future). C{None} values in the matrix are treated
            specially in both cases: nothing is drawn in the cell corresponding
            to C{None}.

          - C{square}: whether the cells of the matrix should be square or not.
            Default is C{True}.

          - C{grid_width}: line width of the grid shown on the matrix. If zero or
            negative, the grid is turned off. The grid is also turned off if the size
            of a cell is less than three times the given line width. Default is C{1}.
            Fractional widths are also allowed.

          - C{border_width}: line width of the border drawn around the matrix.
            If zero or negative, the border is turned off. Default is C{1}.

          - C{row_names}: the names of the rows

          - C{col_names}: the names of the columns.

          - C{values}: values to be displayed in the cells. If C{None} or
            C{False}, no values are displayed. If C{True}, the values come
            from the matrix being plotted. If it is another matrix, the
            values of that matrix are shown in the cells. In this case,
            the shape of the value matrix must match the shape of the
            matrix being plotted.

          - C{value_format}: a format string or a callable that specifies how
            the values should be plotted. If it is a callable, it must be a
            function that expects a single value and returns a string.
            Example: C{"%#.2f"} for floating-point numbers with always exactly
            two digits after the decimal point. See the Python documentation of
            the C{%} operator for details on the format string. If the format
            string is not given, it defaults to the C{str} function.

        If only the row names or the column names are given and the matrix
        is square-shaped, the same names are used for both column and row
        names.
        """
        ...
    
    def min(self, dim=...): # -> list[Any]:
        """Returns the minimum of the matrix along the given dimension

        @param dim: the dimension. 0 means determining the column minimums, 1 means
          determining the row minimums. If C{None}, the global minimum is
          returned.
        """
        ...
    
    def max(self, dim=...): # -> list[Any]:
        """Returns the maximum of the matrix along the given dimension

        @param dim: the dimension. 0 means determining the column maximums, 1 means
          determining the row maximums. If C{None}, the global maximum is
          returned.
        """
        ...
    


class DyadCensus(tuple):
    """Dyad census of a graph.

    This is a pretty simple class - basically it is a tuple, but it allows
    the user to refer to its individual items by the names C{mutual} (or
    C{mut}), C{asymmetric} (or C{asy} or C{asym} or C{asymm}) and C{null}.

    Examples:

      >>> from igraph import Graph
      >>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)
      >>> dc=g.dyad_census()
      >>> print(dc.mutual)            #doctest:+SKIP
      179
      >>> print(dc["asym"])           #doctest:+SKIP
      1609
      >>> print(tuple(dc), list(dc))  #doctest:+SKIP
      (179, 1609, 3162) [179, 1609, 3162]
      >>> print(sorted(dc.as_dict().items()))  #doctest:+ELLIPSIS
      [('asymmetric', ...), ('mutual', ...), ('null', ...)]
    """
    _remap = ...
    def __getitem__(self, idx):
        ...
    
    def __getattr__(self, attr):
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def __str__(self) -> str:
        ...
    
    def as_dict(self): # -> dict[str, Any]:
        """Converts the dyad census to a dict using the known dyad names."""
        ...
    


class TriadCensus(tuple):
    """Triad census of a graph.

    This is a pretty simple class - basically it is a tuple, but it allows
    the user to refer to its individual items by the following triad names:

      - C{003} -- the empty graph
      - C{012} -- a graph with a single directed edge (C{A --> B, C})
      - C{102} -- a graph with a single mutual edge (C{A <-> B, C})
      - C{021D} -- the binary out-tree (C{A <-- B --> C})
      - C{021U} -- the binary in-tree (C{A --> B <-- C})
      - C{021C} -- the directed line (C{A --> B --> C})
      - C{111D} -- C{A <-> B <-- C}
      - C{111U} -- C{A <-> B --> C}
      - C{030T} -- C{A --> B <-- C, A --> C}
      - C{030C} -- C{A <-- B <-- C, A --> C}
      - C{201} -- C{A <-> B <-> C}
      - C{120D} -- C{A <-- B --> C, A <-> C}
      - C{120U} -- C{A --> B <-- C, A <-> C}
      - C{120C} -- C{A --> B --> C, A <-> C}
      - C{210C} -- C{A --> B <-> C, A <-> C}
      - C{300} -- the complete graph (C{A <-> B <-> C, A <-> C})

    Attribute and item accessors are provided. Due to the syntax of Python,
    attribute names are not allowed to start with a number, therefore the
    triad names must be prepended with a lowercase C{t} when accessing
    them as attributes. This is not necessary with the item accessor syntax.

    Examples:

      >>> from igraph import Graph
      >>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)
      >>> tc=g.triad_census()
      >>> print(tc.t003)                    #doctest:+SKIP
      39864
      >>> print(tc["030C"])                 #doctest:+SKIP
      1206
    """
    _remap = ...
    def __getitem__(self, idx):
        ...
    
    def __getattr__(self, attr):
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class UniqueIdGenerator:
    """A dictionary-like class that can be used to assign unique IDs to
    names (say, vertex names).

    Usage:

    >>> gen = UniqueIdGenerator()
    >>> gen["A"]
    0
    >>> gen["B"]
    1
    >>> gen["C"]
    2
    >>> gen["A"]      # Retrieving already existing ID
    0
    >>> gen.add("D")  # Synonym of gen["D"]
    3
    >>> len(gen)      # Number of already used IDs
    4
    >>> "C" in gen
    True
    >>> "E" in gen
    False
    """
    def __init__(self, id_generator=..., initial=...) -> None:
        """Creates a new unique ID generator. C{id_generator} specifies how do we
        assign new IDs to elements that do not have an ID yet. If it is C{None},
        elements will be assigned integer identifiers starting from 0. If it is
        an integer, elements will be assigned identifiers starting from the given
        integer. If it is an iterator or generator, its C{next()} method will be
        called every time a new ID is needed."""
        ...
    
    def __contains__(self, item): # -> bool:
        """Checks whether C{item} already has an ID or not."""
        ...
    
    def __getitem__(self, item):
        """Retrieves the ID corresponding to C{item}. Generates a new ID for
        C{item} if it is the first time we request an ID for it."""
        ...
    
    def __setitem__(self, item, value): # -> None:
        """Overrides the ID for C{item}."""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of items."""
        ...
    
    def reverse_dict(self): # -> dict[Any, Any]:
        """Returns the reverse mapping, i.e., the one that maps from generated
        IDs to their corresponding objects"""
        ...
    
    def values(self): # -> list[Any]:
        """Returns the values stored so far. If the generator generates items
        according to the standard sorting order, the values returned will be
        exactly in the order they were added. This holds for integer IDs for
        instance (but for many other ID generators as well)."""
        ...
    
    add = ...


